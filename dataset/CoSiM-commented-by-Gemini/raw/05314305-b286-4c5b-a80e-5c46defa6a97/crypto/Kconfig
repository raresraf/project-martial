# SPDX-License-Identifier: GPL-2.0
#
# Generic algorithms support
#
config XOR_BLOCKS
	tristate

#
# async_tx api: hardware offloaded memory transfer/transform support
#
source "crypto/async_tx/Kconfig"

#
# Cryptographic API Configuration
#
menuconfig CRYPTO
	tristate "Cryptographic API"
	select CRYPTO_LIB_UTILS
	help
	  This option enables the core Cryptographic API for the Linux kernel.
	  It provides a generic framework for using a wide range of cryptographic
	  primitives, including symmetric ciphers, hash functions, message
	  authentication codes (MACs), and public-key cryptography.

	  The API is designed to be extensible, allowing for both software
	  implementations of algorithms and hardware-accelerated offloading where
	  supported. It serves as the foundation for nearly all cryptographic
	  operations within the kernel, used by subsystems such as IPsec,
	  dm-crypt, fscrypt, and for digital signature verification.

	  If you are building a general-purpose kernel, you should almost
	  certainly say Y or M here.

if CRYPTO

menu "Crypto core or helper"

config CRYPTO_FIPS
	bool "FIPS 200 compliance"
	depends on (CRYPTO_ANSI_CPRNG || CRYPTO_DRBG) && CRYPTO_SELFTESTS
	depends on (MODULE_SIG || !MODULES)
	help
	  This option enables features required for operating the kernel's
	  cryptographic modules in a mode compliant with the Federal
	  Information Processing Standard (FIPS) 200. Enabling this adds a
	  `fips` boot option that, when used, forces the system to run
	  built-in self-tests on all cryptographic algorithms upon startup.
	  If any of these tests fail, the kernel will panic to prevent the
	  use of non-compliant or malfunctioning crypto modules.

	  This is a security-hardening feature primarily intended for systems
	  that must meet strict regulatory compliance standards. You should
	  say N unless you are specifically building a system for a FIPS-
	  regulated environment.

config CRYPTO_FIPS_NAME
	string "FIPS Module Name"
	default "Linux Kernel Cryptographic API"
	depends on CRYPTO_FIPS
	help
	  This option sets the FIPS Module name reported by the Crypto API via
	  the /proc/sys/crypto/fips_name file.

config CRYPTO_FIPS_CUSTOM_VERSION
	bool "Use Custom FIPS Module Version"
	depends on CRYPTO_FIPS
	default n

config CRYPTO_FIPS_VERSION
	string "FIPS Module Version"
	default "(none)"
	depends on CRYPTO_FIPS_CUSTOM_VERSION
	help
	  This option provides the ability to override the FIPS Module Version.
	  By default the KERNELRELEASE value is used.

config CRYPTO_ALGAPI
	tristate
	select CRYPTO_ALGAPI2
	help
	  This option provides the API for cryptographic algorithms. This is the
	  legacy v1 interface.

config CRYPTO_ALGAPI2
	tristate
	help
	  This provides the modern v2 API for cryptographic algorithms, which
	  is the standard for all new algorithm development. It offers a more
	  flexible and extensible interface compared to the legacy API.

config CRYPTO_AEAD
	tristate
	select CRYPTO_AEAD2
	select CRYPTO_ALGAPI
	help
	  Authenticated Encryption with Associated Data (AEAD) cipher support.
	  AEAD ciphers combine encryption and message authentication into a
	  single, integrated step, providing confidentiality, integrity, and
	  authenticity. This is the legacy v1 interface.

config CRYPTO_AEAD2
	tristate
	select CRYPTO_ALGAPI2
	help
	  This provides the modern v2 API for AEAD ciphers. It is required for
	  algorithms like GCM and ChaCha20-Poly1305.

config CRYPTO_SIG
	tristate
	select CRYPTO_SIG2
	select CRYPTO_ALGAPI
	help
	  Provides the API for digital signature algorithms (e.g., RSA, ECDSA).
	  This is the legacy v1 interface.

config CRYPTO_SIG2
	tristate
	select CRYPTO_ALGAPI2
	help
	  This provides the modern v2 API for digital signature algorithms.

config CRYPTO_SKCIPHER
	tristate
	select CRYPTO_SKCIPHER2
	select CRYPTO_ALGAPI
	select CRYPTO_ECB
	help
	  Provides the API for symmetric key ciphers, including both block
	  ciphers (like AES) and stream ciphers (like ChaCha20). This is the
	  legacy v1 interface.

config CRYPTO_SKCIPHER2
	tristate
	select CRYPTO_ALGAPI2
	help
	  This provides the modern v2 API for symmetric key ciphers.

config CRYPTO_HASH
	tristate
	select CRYPTO_HASH2
	select CRYPTO_ALGAPI
	help
	  Provides the API for cryptographic hash functions (e.g., SHA-256,
	  BLAKE2b). This includes support for both synchronous (shash) and
	  asynchronous (ahash) hashing operations. This is the legacy v1
	  interface.

config CRYPTO_HASH2
	tristate
	select CRYPTO_ALGAPI2
	help
	  This provides the modern v2 API for hash functions.

config CRYPTO_RNG
	tristate
	select CRYPTO_RNG2
	select CRYPTO_ALGAPI
	help
	  Provides the API for Random Number Generators (RNGs), which are
	  essential for generating keys, nonces, and other cryptographic
	  material. This is the legacy v1 interface.

config CRYPTO_RNG2
	tristate
	select CRYPTO_ALGAPI2
	help
	  This provides the modern v2 API for Random Number Generators.

config CRYPTO_RNG_DEFAULT
	tristate
	select CRYPTO_DRBG_MENU
	help
	  Selects the default kernel random number generator implementation,
	  typically based on the NIST SP800-90A DRBG framework.

config CRYPTO_AKCIPHER2
	tristate
	select CRYPTO_ALGAPI2
	help
	  This provides the modern v2 API for asymmetric key (public key)
	  ciphers, used for operations like encryption and decryption.

config CRYPTO_AKCIPHER
	tristate
	select CRYPTO_AKCIPHER2
	select CRYPTO_ALGAPI
	help
	  Provides the API for asymmetric key ciphers. This is the legacy v1
	  interface.

config CRYPTO_KPP
	tristate
	select CRYPTO_ALGAPI
	select CRYPTO_KPP2
	help
	  Provides the API for Key-agreement Protocol Primitives (KPP), such as
	  Diffie-Hellman (DH) and Elliptic Curve Diffie-Hellman (ECDH). These
	  are used to securely establish shared secrets over an insecure
	  channel. This is the legacy v1 interface.

config CRYPTO_KPP2
	tristate
	select CRYPTO_ALGAPI2
	help
	  This provides the modern v2 API for Key-agreement Protocol Primitives.

config CRYPTO_ACOMP2
	tristate
	select CRYPTO_ALGAPI2
	select SGL_ALLOC
	help
	  Provides the modern v2 API for asynchronous compression algorithms
	  (e.g., zlib, lz4).

config CRYPTO_ACOMP
	tristate
	select CRYPTO_ALGAPI
	select CRYPTO_ACOMP2
	help
	  Provides the API for asynchronous compression algorithms. This is the
	  legacy v1 interface.

config CRYPTO_HKDF
	tristate
	select CRYPTO_SHA256 if CRYPTO_SELFTESTS
	select CRYPTO_SHA512 if CRYPTO_SELFTESTS
	select CRYPTO_HASH2
	help
	  Enable HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
	  as specified in RFC 5869. HKDF is a standard method for deriving
	  one or more cryptographic keys from a master secret.

config CRYPTO_MANAGER
	tristate
	default CRYPTO_ALGAPI if CRYPTO_SELFTESTS
	select CRYPTO_MANAGER2
	help
	  The cryptographic algorithm manager is a core component of the
	  Crypto API. Its primary function is to manage the registration and
	  lookup of cryptographic algorithms. It allows for the creation of
	  "template" instantiations, where a generic cipher mode (like CBC)
	  is combined with a specific block cipher (like AES) to form a new
	  algorithm, e.g., "cbc(aes)".

	  This is also essential for running the built-in cryptographic
	  self-tests. You should enable this if you need to construct complex
	  cipher modes or if you are enabling self-tests.

config CRYPTO_MANAGER2
	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)
	select CRYPTO_ACOMP2
	select CRYPTO_AEAD2
	select CRYPTO_AKCIPHER2
	select CRYPTO_SIG2
	select CRYPTO_HASH2
	select CRYPTO_KPP2
	select CRYPTO_RNG2
	select CRYPTO_SKCIPHER2
	help
	  This is the internal, modern v2 implementation of the crypto
	  manager, selected automatically when CRYPTO_MANAGER is enabled.
	  It supports all v2 algorithm types.

config CRYPTO_USER
	tristate "Userspace cryptographic algorithm configuration"
	depends on NET
	select CRYPTO_MANAGER
	help
	  This enables a netlink-based interface (AF_ALG) that allows
	  userspace applications to access the kernel's cryptographic
	  implementations. This can be useful for leveraging hardware
	  crypto acceleration from userspace or for providing a unified
	  crypto interface.

config CRYPTO_SELFTESTS
	bool "Enable cryptographic self-tests"
	depends on EXPERT
	help
	  Enable the built-in cryptographic self-tests. These tests verify the
	  correctness of the kernel's implementations for various algorithms.

	  The cryptographic self-tests run at boot time, or at algorithm
	  registration time if algorithms are dynamically loaded later as modules.

	  There are two main use cases for these tests:

	  - Development and pre-release testing: Ensures that new or modified
	    crypto code functions correctly. For this, also enable
	    CRYPTO_SELFTESTS_FULL to get the most comprehensive set of tests.

	  - Production kernels: Acts as a safeguard to prevent buggy drivers
	    from being used and helps meet the pre-operational testing
	    requirements of standards like FIPS 140-3. For production, you
	    should typically not enable the full test suite.

config CRYPTO_SELFTESTS_FULL
	bool "Enable the full set of cryptographic self-tests"
	depends on CRYPTO_SELFTESTS
	help
	  Enable the complete, extended set of test vectors for each
	  cryptographic algorithm. This provides a much more thorough
	  validation than the default self-tests.

	  The full set of tests should be enabled for development and
	  pre-release testing but is generally not recommended for production
	  kernels due to the increased boot time.

	  All crypto code in the kernel is expected to pass the full tests.

config CRYPTO_NULL
	tristate "Null algorithms"
	select CRYPTO_ALGAPI
	select CRYPTO_SKCIPHER
	select CRYPTO_HASH
	help
	  These are 'Null' algorithms that perform no operation. The null
	  cipher is an identity function (plaintext equals ciphertext), and
	  the null hash produces a zero-length digest. They are primarily
	  used by IPsec for testing or for configurations that require an
	  "encryption" or "authentication" algorithm but where no actual
	  cryptographic protection is desired (e.g., ESP with NULL encryption).

config CRYPTO_PCRYPT
	tristate "Parallel crypto engine"
	depends on SMP
	select PADATA
	select CRYPTO_MANAGER
	select CRYPTO_AEAD
	help
	  This option enables a parallel crypto wrapper. It takes a standard
	  synchronous crypto algorithm and parallelizes its execution across
	  multiple CPUs using kernel threads. This can significantly improve
	  throughput for bulk crypto operations on multi-core systems,
	  especially when no hardware acceleration is available.

config CRYPTO_CRYPTD
	tristate "Software async crypto daemon"
	select CRYPTO_SKCIPHER
	select CRYPTO_HASH
	select CRYPTO_MANAGER
	help
	  This provides `cryptd`, a generic software-based asynchronous crypto
	  daemon. It wraps a synchronous, software-only cryptographic algorithm
	  (like a generic C implementation of AES) and exposes it as an
	  asynchronous algorithm. This is useful as a fallback for hardware
	  drivers that require an async cipher for certain operations (e.g.,
	  async AES for use with an async version of a cipher mode like XTS).

config CRYPTO_AUTHENC
	tristate "Authenc support"
	select CRYPTO_AEAD
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	select CRYPTO_HASH
	help
	  Authenc: Combined mode wrapper for IPsec.

	  This is a software-level construction that combines a separate
	  cipher algorithm and a separate authentication (hash) algorithm
	  into a single AEAD-like interface. It is required for IPsec ESP
	  (XFRM_ESP) when not using a dedicated hardware-accelerated AEAD
	  algorithm.

config CRYPTO_KRB5ENC
	tristate "Kerberos 5 combined hash+cipher support"
	select CRYPTO_AEAD
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	select CRYPTO_HASH
	help
	  This provides a combined mode wrapper that implements the encryption
	  and checksumming requirements of the Kerberos 5 GSS-API, as
	  specified in RFC3961 (simplified profile). This is required for
	  Kerberos 5-style encryption used by RPC-based protocols like
	  sunrpc/NFS and rxrpc/AFS.

config CRYPTO_BENCHMARK
	tristate "Crypto benchmarking module"
	depends on m || EXPERT
	select CRYPTO_MANAGER
	help
	  This option enables a simple kernel module (`tcrypt.ko`) for
	  benchmarking the performance of the various cryptographic algorithms
	  available in the kernel.

	  This is mainly intended for developers working on cryptographic
	  algorithms or optimizing their performance. It should not be enabled
	  in production kernels.

config CRYPTO_SIMD
	tristate
	select CRYPTO_CRYPTD
	help
	  Enables a wrapper that allows SIMD-accelerated implementations of
	  algorithms to be used through the standard Crypto API. This often
	  requires the `cryptd` software daemon as a fallback.

config CRYPTO_ENGINE
	tristate
	help
	  Enables the Crypto Engine framework, which provides an API for
	  offloading cryptographic operations to dedicated hardware
	  accelerators.

endmenu

menu "Public-key cryptography"

config CRYPTO_RSA
	tristate "RSA (Rivest-Shamir-Adleman)"
	select CRYPTO_AKCIPHER
	select CRYPTO_MANAGER
	select CRYPTO_SIG
	select MPILIB
	select ASN1
	help
	  Enables the RSA (Rivest-Shamir-Adleman) public key algorithm, as
	  specified in RFC8017. This includes support for both RSA signatures
	  (RSASSA-PKCS1-v1_5, RSASSA-PSS) and RSA encryption
	  (RSAES-PKCS1-v1_5, RSAES-OAEP). It is fundamental for digital
	  signature verification (e.g., for kernel modules and IMA/EVM) and
	  is used in protocols like TLS and IPsec.

config CRYPTO_DH
	tristate "DH (Diffie-Hellman)"
	select CRYPTO_KPP
	select MPILIB
	help
	  Enables the Diffie-Hellman (DH) key exchange algorithm. DH is a
	  method for two parties to establish a shared secret over an insecure
	  communication channel. It is a core component of many cryptographic
	  protocols, including IPsec (IKE) and TLS.

config CRYPTO_DH_RFC7919_GROUPS
	bool "RFC 7919 FFDHE groups"
	depends on CRYPTO_DH
	select CRYPTO_RNG_DEFAULT
	help
	  Enables support for the Finite-Field Diffie-Hellman Ephemeral (FFDHE)
	  groups defined in RFC 7919. These are standardized, well-known groups
	  that provide strong security guarantees and are recommended for use
	  in modern DH key exchanges.

	  This option adds support for the following groups:
	  - ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192

	  If unsure, say N.

config CRYPTO_ECC
	tristate
	select CRYPTO_RNG_DEFAULT
	help
	  Provides core functionalities for Elliptic Curve Cryptography (ECC),
	  including curve definitions and basic point arithmetic. This is a
	  foundational option required by other ECC-based algorithms like ECDH
	  and ECDSA.

config CRYPTO_ECDH
	tristate "ECDH (Elliptic Curve Diffie-Hellman)"
	select CRYPTO_ECC
	select CRYPTO_KPP
	help
	  Enables the Elliptic Curve Diffie-Hellman (ECDH) key exchange
	  algorithm. ECDH is an elliptic curve variant of Diffie-Hellman and
	  is generally more efficient, providing the same level of security
	  with much smaller key sizes. This implementation supports curves
	  NIST P-192, P-256, and P-384 (FIPS 186).

config CRYPTO_ECDSA
	tristate "ECDSA (Elliptic Curve Digital Signature Algorithm)"
	select CRYPTO_ECC
	select CRYPTO_SIG
	select ASN1
	help
	  Enables the Elliptic Curve Digital Signature Algorithm (ECDSA), as
	  specified in FIPS 186 and ISO/IEC 14888-3. ECDSA is the elliptic
	  curve analogue of the DSA algorithm. It is widely used for digital
	  signatures in resource-constrained environments.

	  This implementation supports curves NIST P-192, P-256, P-384, and
	  P-521. Currently, only signature verification is implemented in the
	  generic kernel module.

config CRYPTO_ECRDSA
	tristate "EC-RDSA (Elliptic Curve Russian Digital Signature Algorithm)"
	select CRYPTO_ECC
	select CRYPTO_SIG
	select CRYPTO_STREEBOG
	select OID_REGISTRY
	select ASN1
	help
	  Enables the Elliptic Curve Russian Digital Signature Algorithm
	  (GOST R 34.10-2012), as specified in RFC 7091 and ISO/IEC 14888-3.
	  This is one of the Russian national cryptographic standard algorithms
	  (GOST). Only signature verification is implemented.

config CRYPTO_CURVE25519
	tristate "Curve25519"
	select CRYPTO_KPP
	select CRYPTO_LIB_CURVE25519_GENERIC
	select CRYPTO_LIB_CURVE25519_INTERNAL
	help
	  Enables support for Curve25519, a state-of-the-art elliptic curve
	  offering 128 bits of security and designed for high performance. It
	  is commonly used in Elliptic Curve Diffie-Hellman (ECDH) key
	  agreement and is specified in RFC 7748.

endmenu

menu "Block ciphers"

config CRYPTO_AES
	tristate "AES (Advanced Encryption Standard)"
	select CRYPTO_ALGAPI
	select CRYPTO_LIB_AES
	help
	  AES cipher algorithms (Rijndael)(FIPS-197, ISO/IEC 18033-3)

	  The Advanced Encryption Standard (AES) is the de facto world
	  standard for symmetric block ciphers. It is a substitution-
	  permutation network that is fast in both software and hardware.
	  Its key setup time is excellent, and its key agility is good.
	  Rijndael's very low memory requirements make it very well suited for
	  restricted-space environments. Its operations are among the easiest
	  to defend against power and timing attacks.

	  The AES standard specifies three key sizes: 128, 192 and 256 bits.
	  This option enables the generic C implementation.

config CRYPTO_AES_TI
	tristate "AES (Advanced Encryption Standard) (fixed time)"
	select CRYPTO_ALGAPI
	select CRYPTO_LIB_AES
	help
	  This provides a generic C implementation of AES that is optimized
	  to execute in constant time with respect to the data being
	  processed. This helps mitigate cache-timing side-channel attacks.

	  Instead of using large lookup tables (T-tables), this
	  implementation uses only two 256-byte S-boxes and computes the
	  round transformations on the fly. To further resist timing attacks,
	  it prefetches the tables into cache at the start of each block
	  operation and disables interrupts during the critical section.

	  It is intended for use by modes like CCM and GCM that rely solely
	  on the encryption function.

config CRYPTO_ANUBIS
	tristate "Anubis"
	depends on CRYPTO_USER_API_ENABLE_OBSOLETE
	select CRYPTO_ALGAPI
	help
	  Anubis is a symmetric block cipher that was an entrant in the NESSIE
	  competition. It operates on 128-bit blocks and supports key sizes of
	  128, 160, 192, 224, 256, 288, and 320 bits. It is considered obsolete
	  and should only be enabled for legacy compatibility.

	  See https://web.archive.org/web/20160606112246/http://www.larc.usp.br/~pbarreto/AnubisPage.html
	  for further information.

config CRYPTO_ARIA
	tristate "ARIA"
	select CRYPTO_ALGAPI
	help
	  ARIA is a symmetric block cipher developed in South Korea and defined
	  in RFC 5794. It operates on 128-bit blocks and supports key sizes of
	  128, 192, and 256 bits.

	  See:
	  https://seed.kisa.or.kr/kisa/algorithm/EgovAriaInfo.do

config CRYPTO_BLOWFISH
	tristate "Blowfish"
	select CRYPTO_ALGAPI
	select CRYPTO_BLOWFISH_COMMON
	help
	  Blowfish is a symmetric block cipher designed by Bruce Schneier.
	  It has a 64-bit block size and a variable key length from 32 bits
	  up to 448 bits. It's known for being fast and is well-suited for
	  software implementation on "large microprocessors".

	  See https://www.schneier.com/blowfish.html for further information.

config CRYPTO_BLOWFISH_COMMON
	tristate
	help
	  Common parts of the Blowfish cipher algorithm shared by the
	  generic C and the assembler implementations.

config CRYPTO_CAMELLIA
	tristate "Camellia"
	select CRYPTO_ALGAPI
	help
	  Camellia is a symmetric block cipher developed jointly by NTT and
	  Mitsubishi Electric Corporation. It is approved for use by the ISO/IEC,
	  the European Union's NESSIE project, and the Japanese CRYPTREC project.
	  It has a 128-bit block size and supports key sizes of 128, 192, and 256
	  bits, similar to AES.

	  See https://info.isl.ntt.co.jp/crypt/eng/camellia/ for further information.

config CRYPTO_CAST_COMMON
	tristate
	help
	  Common parts of the CAST cipher algorithms shared by the
	  generic c and the assembler implementations.

config CRYPTO_CAST5
	tristate "CAST5 (CAST-128)"
	select CRYPTO_ALGAPI
	select CRYPTO_CAST_COMMON
	help
	  CAST5 (also known as CAST-128) is a symmetric block cipher defined
	  in RFC 2144. It has a 64-bit block size and supports key sizes up
	  to 128 bits.

config CRYPTO_CAST6
	tristate "CAST6 (CAST-256)"
	select CRYPTO_ALGAPI
	select CRYPTO_CAST_COMMON
	help
	  CAST6 (also known as CAST-256) is a symmetric block cipher defined
	  in RFC 2612. It was a candidate for the AES competition. It has a
	  128-bit block size and supports key sizes up to 256 bits.

config CRYPTO_DES
	tristate "DES and Triple DES EDE"
	select CRYPTO_ALGAPI
	select CRYPTO_LIB_DES
	help
	  Enables the Data Encryption Standard (DES) and Triple DES (3DES)
	  symmetric block ciphers. DES (FIPS 46-2) is the original standard
	  with a 56-bit key and is now considered insecure for most purposes.
	  Triple DES (FIPS 46-3) applies the DES cipher three times in an
	  Encrypt-Decrypt-Encrypt (EDE) sequence, increasing the effective
	  key strength. Both are largely legacy algorithms.

config CRYPTO_FCRYPT
	tristate "FCrypt"
	select CRYPTO_ALGAPI
	select CRYPTO_SKCIPHER
	help
	  FCrypt is a block cipher used by the RxRPC (AFS) network protocol.

	  See https://ota.polyonymo.us/fcrypt-paper.txt

config CRYPTO_KHAZAD
	tristate "Khazad"
	depends on CRYPTO_USER_API_ENABLE_OBSOLETE
	select CRYPTO_ALGAPI
	help
	  Khazad is a symmetric block cipher that was a finalist in the NESSIE
	  competition. It has a 64-bit block size and a 128-bit key. It is
	  considered obsolete.

	  See https://web.archive.org/web/20171011071731/http://www.larc.usp.br/~pbarreto/KhazadPage.html
	  for further information.

config CRYPTO_SEED
	tristate "SEED"
	depends on CRYPTO_USER_API_ENABLE_OBSOLETE
	select CRYPTO_ALGAPI
	help
	  SEED is a 128-bit symmetric block cipher that was a national
	  standard in South Korea (RFC 4269). It has a 128-bit block size
	  and a 128-bit key. It is now largely considered a legacy algorithm.

	  See https://seed.kisa.or.kr/kisa/algorithm/EgovSeedInfo.do
	  for further information.

config CRYPTO_SERPENT
	tristate "Serpent"
	select CRYPTO_ALGAPI
	help
	  Serpent is a symmetric block cipher that was a finalist in the AES
	  competition. It was designed by Ross Anderson, Eli Biham, and Lars
	  Knudsen. It has a 128-bit block size and supports key sizes of 128,
	  192, or 256 bits. It was designed to be highly secure and conservative
	  in its design, often favored in high-security applications over speed.

	  See https://www.cl.cam.ac.uk/~rja14/serpent.html for further information.

config CRYPTO_SM4
	tristate

config CRYPTO_SM4_GENERIC
	tristate "SM4 (ShangMi 4)"
	select CRYPTO_ALGAPI
	select CRYPTO_SM4
	help
	  SM4 is a symmetric block cipher that is part of the Chinese National
	  Standard for commercial cryptography (OSCCA GB/T 32907-2016). It has
	  a 128-bit block size and a 128-bit key.

	  Originally created for use in protecting wireless networks (WAPI), it
	  is now a general-purpose block cipher standard in China.

	  See https://eprint.iacr.org/2008/329.pdf for further information.

	  If unsure, say N.

config CRYPTO_TEA
	tristate "TEA, XTEA and XETA"
	depends on CRYPTO_USER_API_ENABLE_OBSOLETE
	select CRYPTO_ALGAPI
	help
	  The Tiny Encryption Algorithm (TEA) and its variants (XTEA, XETA) are
	  simple block ciphers known for their small code size and simple
	  implementation. They are generally considered obsolete for most
	  security applications. XTEA is a correction to a key weakness in the
	  original TEA. XETA is a non-standard, bug-compatible implementation.

config CRYPTO_TWOFISH
	tristate "Twofish"
	select CRYPTO_ALGAPI
	select CRYPTO_TWOFISH_COMMON
	help
	  Twofish is a symmetric block cipher designed by Bruce Schneier et al.
	  and was a finalist in the AES competition. It has a 128-bit block
	  size and supports key sizes of 128, 192, and 256 bits. It is known
	  for its flexible design and good performance across a wide range of
	  platforms.

	  See https://www.schneier.com/twofish.html for further information.

config CRYPTO_TWOFISH_COMMON
	tristate
	help
	  Common parts of the Twofish cipher algorithm shared by the
	  generic c and the assembler implementations.

endmenu

menu "Length-preserving ciphers and modes"

config CRYPTO_ADIANTUM
	tristate "Adiantum"
	select CRYPTO_CHACHA20
	select CRYPTO_LIB_POLY1305_GENERIC
	select CRYPTO_NHPOLY1305
	select CRYPTO_MANAGER
	help
	  Adiantum is a tweakable, wide-block, length-preserving encryption
	  mode designed for fast and secure disk encryption, especially on
	  CPUs without dedicated crypto instructions (like AES-NI).

	  It is constructed from the XChaCha stream cipher, a polynomial hash
	  (NHPoly1305), and a single AES-256 block cipher invocation per sector.
	  On CPUs without hardware AES acceleration, Adiantum is significantly
	  faster than AES-XTS.

	  Unlike XTS, Adiantum is a true wide-block mode, providing a stronger
	  guarantee of security against manipulation of ciphertext blocks. It
	  is an excellent choice for full-disk encryption on mobile and
	  low-power devices.

	  If unsure, say N.

config CRYPTO_ARC4
	tristate "ARC4 (Alleged Rivest Cipher 4)"
	depends on CRYPTO_USER_API_ENABLE_OBSOLETE
	select CRYPTO_SKCIPHER
	select CRYPTO_LIB_ARC4
	help
	  ARC4 is a stream cipher algorithm. It is required for the legacy
	  Wi-Fi security protocol WEP (Wired Equivalent Privacy). ARC4 is known
	  to have significant cryptographic weaknesses and its use is strongly
	  discouraged in any new applications. Enable this only for
	  compatibility with old systems that require WEP.

config CRYPTO_CHACHA20
	tristate "ChaCha"
	select CRYPTO_LIB_CHACHA
	select CRYPTO_LIB_CHACHA_GENERIC
	select CRYPTO_SKCIPHER
	help
	  This enables the ChaCha family of high-speed stream ciphers, designed
	  by Daniel J. Bernstein.
	  - ChaCha20: A 256-bit stream cipher specified in RFC 7539. It is very
	    fast in software and widely used in protocols like TLS 1.3 and
	    WireGuard.
	  - XChaCha20: An extended-nonce variant of ChaCha20, increasing the
	    nonce size from 96 bits to 192 bits. This makes it much safer to
	    use in applications where nonces might be randomly generated.
	  - XChaCha12: A reduced-round (12 rounds instead of 20) version of
	    XChaCha20, offering higher performance with a reduced security
	    margin.

config CRYPTO_CBC
	tristate "CBC (Cipher Block Chaining)"
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	help
	  Cipher Block Chaining (CBC) is a widely used block cipher mode of
	  operation (NIST SP800-38A). In CBC mode, each block of plaintext is
	  XORed with the previous ciphertext block before being encrypted.
	  This ensures that identical plaintext blocks encrypt to different
	  ciphertext blocks.

	  This mode is required for IPsec ESP (XFRM_ESP).

config CRYPTO_CTR
	tristate "CTR (Counter)"
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	help
	  Counter (CTR) mode is a block cipher mode of operation that turns a
	  block cipher into a stream cipher (NIST SP800-38A). It generates the
	  next keystream block by encrypting successive values of a "counter".
	  CTR mode is highly parallelizable and has desirable performance
	  characteristics.

config CRYPTO_CTS
	tristate "CTS (Cipher Text Stealing)"
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	help
	  Cipher Text Stealing (CTS) is a block cipher mode that enables
	  block ciphers to process messages that are not a multiple of the
	  block size, without requiring padding. This implementation follows
	  the CBC-CS3 variant specified in the NIST Addendum to SP800-38A.

	  This mode is required for Kerberos GSS-API mechanisms using AES.

config CRYPTO_ECB
	tristate "ECB (Electronic Codebook)"
	select CRYPTO_SKCIPHER2
	select CRYPTO_MANAGER
	help
	  Electronic Codebook (ECB) is the simplest block cipher mode (NIST
	  SP800-38A). Each block of plaintext is encrypted independently.
	  Because identical plaintext blocks are encrypted into identical
	  ciphertext blocks, it does not hide data patterns well and is
	  generally not recommended for use in cryptographic protocols.
	  However, it is a building block for other modes like XTS and LRW.

config CRYPTO_HCTR2
	tristate "HCTR2"
	select CRYPTO_XCTR
	select CRYPTO_POLYVAL
	select CRYPTO_MANAGER
	help
	  HCTR2 is a high-performance, tweakable, length-preserving encryption
	  mode for storage encryption. It is particularly efficient on
	  processors with hardware acceleration for AES and carryless
	  multiplication (e.g., x86 with AES-NI and CLMUL, or ARMv8 with crypto
	  extensions).

	  See https://eprint.iacr.org/2021/1441

config CRYPTO_LRW
	tristate "LRW (Liskov Rivest Wagner)"
	select CRYPTO_LIB_GF128MUL
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	select CRYPTO_ECB
	help
	  Liskov, Rivest, Wagner (LRW) is a tweakable narrow-block encryption
	  mode primarily designed for disk encryption. It provides stronger
	  security than ECB by "tweaking" the encryption of each block with its
	  sector index, preventing blocks from being copied between sectors.
	  It is a predecessor to the more widely used XTS mode.

	  See https://people.csail.mit.edu/rivest/pubs/LRW02.pdf

config CRYPTO_PCBC
	tristate "PCBC (Propagating Cipher Block Chaining)"
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	help
	  Propagating Cipher Block Chaining (PCBC) is a block cipher mode of
	  operation where errors in the ciphertext propagate indefinitely when
	  decrypting. This mode is used by the RxRPC (AFS) protocol.

config CRYPTO_XCTR
	tristate
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	help
	  XOR Counter (XCTR) mode is a variant of the standard CTR mode used
	  as a building block for the HCTR2 encryption mode. It uses a
	  combination of XORs and little-endian addition instead of the
	  standard big-endian arithmetic for the counter.

config CRYPTO_XTS
	tristate "XTS (XOR Encrypt XOR with ciphertext stealing)"
	select CRYPTO_SKCIPHER
	select CRYPTO_MANAGER
	select CRYPTO_ECB
	help
	  XTS (XOR-Encrypt-XOR with ciphertext stealing) is the standard mode
	  of operation for full-disk encryption (NIST SP800-38E, IEEE 1619).
	  It is a tweakable wide-block mode that encrypts each data unit
	  (e.g., a disk sector) independently. It is designed to be highly
	  performant and parallelizable.

config CRYPTO_NHPOLY1305
	tristate
	select CRYPTO_HASH
	select CRYPTO_LIB_POLY1305_GENERIC
	help
	  This provides the NH + Poly1305 ε-almost-∆-universal (ε-ADU) hash
	  function, which is a core component of the Adiantum encryption mode.
	  It is not a general-purpose cryptographic hash.

endmenu

menu "AEAD (authenticated encryption with associated data) ciphers"

config CRYPTO_AEGIS128
	tristate "AEGIS-128"
	select CRYPTO_AEAD
	select CRYPTO_AES  # for AES S-box tables
	help
	  AEGIS-128 is a high-performance Authenticated Encryption with
	  Associated Data (AEAD) algorithm. It is designed for speed in
	  software and was a candidate in the CAESAR competition.

config CRYPTO_AEGIS128_SIMD
	bool "AEGIS-128 (arm NEON, arm64 NEON)"
	depends on CRYPTO_AEGIS128 && ((ARM || ARM64) && KERNEL_MODE_NEON)
	default y
	help
	  Enables SIMD-accelerated implementations of AEGIS-128 using NEON
	  instructions on ARM and ARM64 architectures for improved performance.

config CRYPTO_CHACHA20POLY1305
	tristate "ChaCha20-Poly1305"
	select CRYPTO_CHACHA20
	select CRYPTO_AEAD
	select CRYPTO_LIB_POLY1305
	select CRYPTO_MANAGER
	help
	  This enables the ChaCha20-Poly1305 AEAD construction, as specified
	  in RFC 8439. It combines the ChaCha20 stream cipher for encryption
	  with the Poly1305 message authentication code for integrity and
	  authenticity. It is extremely fast in software and is a mandatory
	  cipher suite in TLS 1.3 and the core of the WireGuard VPN protocol.

config CRYPTO_CCM
	tristate "CCM (Counter with Cipher Block Chaining-MAC)"
	select CRYPTO_CTR
	select CRYPTO_HASH
	select CRYPTO_AEAD
	select CRYPTO_MANAGER
	help
	  Counter with Cipher Block Chaining-Message Authentication Code (CCM)
	  is an AEAD mode for block ciphers specified in NIST SP800-38C. It
	  combines CTR mode for encryption with CBC-MAC for authentication. It
	  is widely used in standards like IEEE 802.15.4 (Zigbee) and WPA2.

config CRYPTO_GCM
	tristate "GCM (Galois/Counter Mode) and GMAC (GCM MAC)"
	select CRYPTO_CTR
	select CRYPTO_AEAD
	select CRYPTO_GHASH
	select CRYPTO_MANAGER
	help
	  Galois/Counter Mode (GCM) is a high-performance AEAD mode for block
	  ciphers specified in NIST SP800-38D. It combines CTR mode for
	  encryption with a universal hash function (GHASH) over a binary
	  Galois field for authentication. It is highly parallelizable and
	  efficient, especially with hardware support.

	  GMAC is a variant that provides authentication only. GCM/GMAC is
	  required for IPsec ESP (XFRM_ESP) and widely used in TLS.

config CRYPTO_GENIV
	tristate
	select CRYPTO_AEAD
	select CRYPTO_MANAGER
	select CRYPTO_RNG_DEFAULT
	help
	  This provides the generic IV (Initialization Vector) generator API,
	  which allows different methods for generating IVs for encryption.

config CRYPTO_SEQIV
	tristate "Sequence Number IV Generator"
	select CRYPTO_GENIV
	help
	  This IV generator creates an Initialization Vector (IV) by XORing a
	  sequence number with a salt. This is a simple and deterministic IV
	  generation method primarily used with CTR mode ciphers. It is required
	  for certain IPsec ESP (XFRM_ESP) configurations.

config CRYPTO_ECHAINIV
	tristate "Encrypted Chain IV Generator"
	select CRYPTO_GENIV
	help
	  This IV generator creates an Initialization Vector (IV) by encrypting
	  a sequence number that has been XORed with a salt. This method
	  produces less predictable IVs than a simple sequence number. It is
	  the default IV generation algorithm for CBC mode in the kernel.

config CRYPTO_ESSIV
	tristate "Encrypted Salt-Sector IV Generator"
	select CRYPTO_AUTHENC
	help
	  Encrypted Salt-Sector IV (ESSIV) is an IV generation method used to
	  protect against watermarking attacks in disk encryption. It generates
	  the IV for a sector by encrypting the sector number with a key derived
	  from the main disk encryption key.

	  ESSIV is used by dm-crypt and fscrypt to make low-entropy IV sources
	  (like a simple sector number) suitable for block encryption modes
	  like CBC.

	  Note that the use of ESSIV is not recommended for new deployments, as
	  wide-block modes like XTS and Adiantum are preferred. Enable this only
	  for compatibility with existing encrypted volumes.

endmenu

menu "Hashes, digests, and MACs"

config CRYPTO_BLAKE2B
	tristate "BLAKE2b"
	select CRYPTO_HASH
	help
	  BLAKE2b is a cryptographic hash function specified in RFC 7693. It is
	  a successor to BLAKE and is often faster than MD5, SHA-1, SHA-2, and
	  SHA-3, yet provides at least as much security.

	  BLAKE2b is optimized for 64-bit platforms and can produce digests of
	  any size between 1 and 64 bytes. A keyed hash (MAC) mode is also
	  implemented. It is used by filesystems like btrfs and protocols like
	  WireGuard.

	  See https://blake2.net for further information.

config CRYPTO_CMAC
	tristate "CMAC (Cipher-based MAC)"
	select CRYPTO_HASH
	select CRYPTO_MANAGER
	help
	  Cipher-based Message Authentication Code (CMAC) is a MAC algorithm
	  based on a block cipher (like AES). It is specified in NIST SP800-38B
	  and RFC 4493. It is a standard way to generate a MAC from a block
	  cipher.

config CRYPTO_GHASH
	tristate "GHASH"
	select CRYPTO_HASH
	select CRYPTO_LIB_GF128MUL
	help
	  GHASH is the universal hash function used in Galois/Counter Mode
	  (GCM). It operates in the Galois field GF(2^128) and provides
	  authentication for GCM and GMAC. This option enables the standalone
	  GHASH algorithm.

config CRYPTO_HMAC
	tristate "HMAC (Keyed-Hash MAC)"
	select CRYPTO_HASH
	select CRYPTO_MANAGER
	help
	  Keyed-Hash Message Authentication Code (HMAC) is a mechanism for
	  calculating a MAC using a cryptographic hash function (like SHA-256)
	  in combination with a secret key (FIPS 198, RFC 2104).

	  This is a fundamental building block for many security protocols and
	  is required for IPsec AH (XFRM_AH) and IPsec ESP (XFRM_ESP).

config CRYPTO_MD4
	tristate "MD4"
	select CRYPTO_HASH
	help
	  MD4 is a message digest algorithm (RFC 1320) that produces a 128-bit
	  hash value. It is severely compromised and cryptographically broken.
	  Do not use it for any security-related purpose. It should only be
	  enabled for compatibility with legacy protocols that require it
	  (e.g., NTLM).

config CRYPTO_MD5
	tristate "MD5"
	select CRYPTO_HASH
	help
	  MD5 is a widely used message digest algorithm (RFC 1321) producing a
	  128-bit hash value. While faster than SHA-1, it is considered
	  cryptographically broken due to the discovery of practical collision
	  attacks. It must not be used for digital signatures or other
	  applications requiring collision resistance. It may still be
	  acceptable for non-cryptographic checksumming.

config CRYPTO_MICHAEL_MIC
	tristate "Michael MIC"
	select CRYPTO_HASH
	help
	  Michael is a Message Integrity Code (MIC) specifically designed for
	  use in the IEEE 802.11i TKIP protocol (the basis for WPA). It has
	  known weaknesses and should not be used for any other purpose. Enable
	  this only if you require TKIP support for legacy Wi-Fi clients.

config CRYPTO_POLYVAL
	tristate
	select CRYPTO_HASH
	select CRYPTO_LIB_GF128MUL
	help
	  POLYVAL is a universal hash function over GF(2^128), similar to
	  GHASH but with a different bit ordering. It is used as a core
	  component of the HCTR2 encryption mode. It is not a general-purpose
	  cryptographic hash function.

config CRYPTO_RMD160
	tristate "RIPEMD-160"
	select CRYPTO_HASH
	help
	  RIPEMD-160 is a 160-bit cryptographic hash function (ISO/IEC 10118-3).
	  It was designed as a secure replacement for 128-bit hash functions
	  like MD5. Its security is comparable to SHA-1, and there are no known
	  practical attacks against the full RIPEMD-160.

	  See https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
	  for further information.

config CRYPTO_SHA1
	tristate "SHA-1"
	select CRYPTO_HASH
	select CRYPTO_LIB_SHA1
	help
	  SHA-1 is a 160-bit secure hash algorithm (FIPS 180). It is no longer
	  considered secure against well-funded attackers due to practical
	  collision attacks. Its use is being phased out in favor of the SHA-2
	  family. Enable this for compatibility with older protocols and
	  systems.

config CRYPTO_SHA256
	tristate "SHA-224 and SHA-256"
	select CRYPTO_HASH
	select CRYPTO_LIB_SHA256
	select CRYPTO_LIB_SHA256_GENERIC
	help
	  Enables the SHA-2 family of secure hash algorithms with 224-bit and
	  256-bit outputs (FIPS 180, ISO/IEC 10118-3). SHA-256 is one of the
	  most widely used hash functions and is a standard for many modern
	  applications, including digital signatures, TLS, and blockchain
	  technology.

	  This is required for IPsec, and used by btrfs, Ceph, NFS, and SMB.

config CRYPTO_SHA512
	tristate "SHA-384 and SHA-512"
	select CRYPTO_HASH
	help
	  Enables the SHA-2 family of secure hash algorithms with 384-bit and
	  512-bit outputs (FIPS 180, ISO/IEC 10118-3). These are generally used
	  in applications requiring higher security levels. SHA-512 is often
	  faster than SHA-256 on 64-bit architectures.

config CRYPTO_SHA3
	tristate "SHA-3"
	select CRYPTO_HASH
	help
	  Enables the SHA-3 family of secure hash algorithms (FIPS 202), the
	  winner of the NIST hash function competition. SHA-3 is based on the
	  Keccak sponge construction and has a different internal structure
	  from SHA-1 and SHA-2, providing a valuable alternative.

config CRYPTO_SM3_GENERIC
	tristate "SM3 (ShangMi 3)"
	select CRYPTO_HASH
	select CRYPTO_LIB_SM3
	help
	  SM3 is a 256-bit cryptographic hash function that is part of the
	  Chinese Commercial Cryptography suite (GM/T 0004-2012). It is a
	  required standard for many applications within China.

	  References:
	  http://www.oscca.gov.cn/UpFile/20101222141857786.pdf
	  https://datatracker.ietf.org/doc/html/draft-shen-sm3-hash

config CRYPTO_STREEBOG
	tristate "Streebog"
	select CRYPTO_HASH
	help
	  Streebog is a cryptographic hash function that is a Russian national
	  standard (GOST R 34.11-2012, RFC 6986). It supports 256-bit and
	  512-bit output sizes.

	  References:
	  https://tc26.ru/upload/iblock/fed/feddbb4d26b685903faa2ba11aea43f6.pdf
	  https://tools.ietf.org/html/rfc6986

config CRYPTO_WP512
	tristate "Whirlpool"
	select CRYPTO_HASH
	help
	  Whirlpool is a cryptographic hash function designed by Vincent Rijmen
	  and Paulo S. L. M. Barreto. It produces a 512-bit hash digest.
	  It was a NESSIE selection and is standardized under ISO/IEC 10118-3.

	  See https://web.archive.org/web/20171129084214/http://www.larc.usp.br/~pbarreto/WhirlpoolPage.html
	  for further information.

config CRYPTO_XCBC
	tristate "XCBC-MAC (Extended Cipher Block Chaining MAC)"
	select CRYPTO_HASH
	select CRYPTO_MANAGER
	help
	  XCBC is a block-cipher-based MAC algorithm that is provably secure
	  assuming the underlying block cipher is a pseudorandom function. It
	  is specified in RFC 3566.

config CRYPTO_XXHASH
	tristate "xxHash"
	select CRYPTO_HASH
	select XXHASH
	help
	  xxHash is an extremely fast non-cryptographic hash algorithm,
	  working at speeds close to RAM limits. It is useful for generating
	  high-quality checksums and for use in hash tables, but it is NOT
	  suitable for cryptographic purposes (e.g., signatures, MACs).

	  Used by filesystems like btrfs and zstd compression.

endmenu

menu "CRCs (cyclic redundancy checks)"

config CRYPTO_CRC32C
	tristate "CRC32c"
	select CRYPTO_HASH
	select CRC32
	help
	  This enables the CRC32c algorithm, which uses a specific polynomial
	  (the Castagnoli polynomial) chosen for its good error-detection
	  properties. It is specified in RFC 3720 for use with iSCSI.

	  It is not a cryptographic hash, but is used for data integrity
	  checks in storage and networking protocols like btrfs, ext4, jbd2,
	  NVMeoF/TCP, and iSCSI.

config CRYPTO_CRC32
	tristate "CRC32"
	select CRYPTO_HASH
	select CRC32
	help
	  This enables the standard CRC32 algorithm as used in Ethernet (IEEE
	  802.3) and many other protocols (e.g., gzip, PNG). It is used for
	  data integrity checks, not for cryptographic security.

	  Used by RoCEv2 and f2fs.

endmenu

menu "Compression"

config CRYPTO_DEFLATE
	tristate "Deflate"
	select CRYPTO_ALGAPI
	select CRYPTO_ACOMP2
	select ZLIB_INFLATE
	select ZLIB_DEFLATE
	help
	  This enables the Deflate compression algorithm (RFC 1951), which is
	  a combination of LZ77 and Huffman coding. It provides a good balance
	  of compression ratio and speed. It is used by IPsec with the IPCOMP
	  protocol (RFC 3173).

config CRYPTO_LZO
	tristate "LZO"
	select CRYPTO_ALGAPI
	select CRYPTO_ACOMP2
	select LZO_COMPRESS
	select LZO_DECOMPRESS
	help
	  This enables the LZO (Lempel-Ziv-Oberhumer) compression algorithm,
	  which is optimized for very high decompression speed.

	  See https://www.oberhumer.com/opensource/lzo/ for further information.

config CRYPTO_842
	tristate "842"
	select CRYPTO_ALGAPI
	select CRYPTO_ACOMP2
	select 842_COMPRESS
	select 842_DECOMPRESS
	help
	  This enables the 842 compression algorithm from IBM, which is
	  designed for high-throughput, low-latency applications.

	  See https://github.com/plauth/lib842 for further information.

config CRYPTO_LZ4
	tristate "LZ4"
	select CRYPTO_ALGAPI
	select CRYPTO_ACOMP2
	select LZ4_COMPRESS
	select LZ4_DECOMPRESS
	help
	  This enables the LZ4 compression algorithm, which is focused on
	  extremely high compression and decompression speeds at the cost of a
	  lower compression ratio compared to algorithms like Deflate.

	  See https://github.com/lz4/lz4 for further information.

config CRYPTO_LZ4HC
	tristate "LZ4HC"
	select CRYPTO_ALGAPI
	select CRYPTO_ACOMP2
	select LZ4HC_COMPRESS
	select LZ4_DECOMPRESS
	help
	  This enables the LZ4 High Compression (HC) mode. It provides a better
	  compression ratio than standard LZ4, at the cost of significantly
	  slower compression speed. Decompression speed remains the same as
	  standard LZ4.

	  See https://github.com/lz4/lz4 for further information.

config CRYPTO_ZSTD
	tristate "Zstd"
	select CRYPTO_ALGAPI
	select CRYPTO_ACOMP2
	select ZSTD_COMPRESS
	select ZSTD_DECOMPRESS
	help
	  This enables the Zstandard (zstd) compression algorithm. It offers
	  a wide range of compression/speed trade-offs, often providing better
	  compression than Deflate at comparable or faster speeds.

	  See https://github.com/facebook/zstd for further information.

endmenu

menu "Random number generation"

config CRYPTO_ANSI_CPRNG
	tristate "ANSI PRNG (Pseudo Random Number Generator)"
	select CRYPTO_AES
	select CRYPTO_RNG
	help
	  Enables a Pseudo Random Number Generator (PRNG) based on the ANSI
	  X9.31 Appendix A.2.4 standard. This implementation uses the AES
	  block cipher in a CTR-like construction to generate a deterministic
	  sequence of pseudo-random numbers from a given seed.

	  Note that this is a deterministic generator and is required if
	  CRYPTO_FIPS is selected.

menuconfig CRYPTO_DRBG_MENU
	tristate "NIST SP800-90A DRBG (Deterministic Random Bit Generator)"
	help
	  This enables the framework for Deterministic Random Bit Generators
	  (DRBGs) as specified in NIST SP800-90A. A DRBG produces a sequence
	  of bits from a secret seed value using a cryptographic algorithm.
	  It is the standard framework for generating cryptographic-quality
	  random numbers in the kernel.

	  In the following submenu, you must select one or more of the DRBG
	  constructions (Hash_DRBG, CTR_DRBG).

if CRYPTO_DRBG_MENU

config CRYPTO_DRBG_HMAC
	bool
	default y
	select CRYPTO_HMAC
	select CRYPTO_SHA512

config CRYPTO_DRBG_HASH
	bool "Hash_DRBG"
	select CRYPTO_SHA256
	help
	  This enables the Hash_DRBG variant as defined in NIST SP800-90A.
	  This construction uses a cryptographic hash function (e.g., SHA-256)
	  to generate the pseudo-random output.

config CRYPTO_DRBG_CTR
	bool "CTR_DRBG"
	select CRYPTO_AES
	select CRYPTO_CTR
	help
	  This enables the CTR_DRBG variant as defined in NIST SP800-90A.
	  This construction uses a block cipher in Counter (CTR) mode (e.g.,
	  AES-CTR) to generate the pseudo-random output.

config CRYPTO_DRBG
	tristate
	default CRYPTO_DRBG_MENU
	select CRYPTO_RNG
	select CRYPTO_JITTERENTROPY
	help
	  Top-level option to enable the selected DRBG mechanisms.

endif	# if CRYPTO_DRBG_MENU

config CRYPTO_JITTERENTROPY
	tristate "CPU Jitter Non-Deterministic RNG (Random Number Generator)"
	select CRYPTO_RNG
	select CRYPTO_SHA3
	help
	  Enables the CPU Jitter-based entropy source. This is a non-
	  deterministic random number generator that harvests entropy from the
	  timing variations (jitter) of CPU execution. It measures the
	  unpredictable fluctuations in the time it takes to execute a code
	  loop, which are caused by complex micro-architectural interactions.

	  It acts as a true entropy source (compliant with NIST SP800-90B)
	  and is used to seed the kernel's primary DRBG.

	  See https://www.chronox.de/jent/

if CRYPTO_JITTERENTROPY
if CRYPTO_FIPS && EXPERT

choice
	prompt "CPU Jitter RNG Memory Size"
	default CRYPTO_JITTERENTROPY_MEMSIZE_2
	help
	  The Jitter RNG measures the execution time of memory accesses.
	  Multiple consecutive memory accesses are performed. If the memory
	  size fits into a cache (e.g. L1), only the memory access timing
	  to that cache is measured. The closer the cache is to the CPU
	  the less variations are measured and thus the less entropy is
	  obtained. Thus, if the memory size fits into the L1 cache, the
	  obtained entropy is less than if the memory size fits within
	  L1 + L2, which in turn is less if the memory fits into
	  L1 + L2 + L3. By selecting a different memory size, you can target
	  different levels of the memory hierarchy to change the rate and
	  quality of the entropy produced.

	config CRYPTO_JITTERENTROPY_MEMSIZE_2
		bool "2048 Bytes (default)"

	config CRYPTO_JITTERENTROPY_MEMSIZE_128
		bool "128 kBytes"

	config CRYPTO_JITTERENTROPY_MEMSIZE_1024
		bool "1024 kBytes"

	config CRYPTO_JITTERENTROPY_MEMSIZE_8192
		bool "8192 kBytes"
endchoice

config CRYPTO_JITTERENTROPY_MEMORY_BLOCKS
	int
	default 64 if CRYPTO_JITTERENTROPY_MEMSIZE_2
	default 512 if CRYPTO_JITTERENTROPY_MEMSIZE_128
	default 1024 if CRYPTO_JITTERENTROPY_MEMSIZE_1024
	default 4096 if CRYPTO_JITTERENTROPY_MEMSIZE_8192

config CRYPTO_JITTERENTROPY_MEMORY_BLOCKSIZE
	int
	default 32 if CRYPTO_JITTERENTROPY_MEMSIZE_2
	default 256 if CRYPTO_JITTERENTROPY_MEMSIZE_128
	default 1024 if CRYPTO_JITTERENTROPY_MEMSIZE_1024
	default 2048 if CRYPTO_JITTERENTROPY_MEMSIZE_8192

config CRYPTO_JITTERENTROPY_OSR
	int "CPU Jitter RNG Oversampling Rate"
	range 1 15
	default 3
	help
	  The Jitter RNG allows the specification of an oversampling rate (OSR).
	  The Jitter RNG operation requires a fixed number of timing
	  measurements to produce one output block of random data. The
	  OSR value multiplies this number, effectively oversampling the
	  timing measurements. This is useful for hardware with coarse-grained
	  timers, as it allows the RNG to accumulate sufficient entropy, but
	  it increases the time required to generate random numbers.

config CRYPTO_JITTERENTROPY_TESTINTERFACE
	bool "CPU Jitter RNG Test Interface"
	help
	  This enables a debugfs interface that allows a privileged process to
	  capture the raw, unconditioned high-resolution time stamp data
	  collected by the Jitter RNG. This is intended for statistical
	  analysis and validation of the entropy source ONLY.

	  Enabling this option makes the Jitter RNG operate in an insecure
	  mode. It is not suitable for production systems.

	  If unsure, select N.

endif	# if CRYPTO_FIPS && EXPERT

if !(CRYPTO_FIPS && EXPERT)

config CRYPTO_JITTERENTROPY_MEMORY_BLOCKS
	int
	default 64

config CRYPTO_JITTERENTROPY_MEMORY_BLOCKSIZE
	int
	default 32

config CRYPTO_JITTERENTROPY_OSR
	int
	default 1

config CRYPTO_JITTERENTROPY_TESTINTERFACE
	bool

endif	# if !(CRYPTO_FIPS && EXPERT)
endif	# if CRYPTO_JITTERENTROPY

config CRYPTO_KDF800108_CTR
	tristate
	select CRYPTO_HMAC
	select CRYPTO_SHA256
	help
	  Enable the Key Derivation Function (KDF) in counter mode as specified
	  in NIST SP800-108. This KDF uses HMAC as its underlying
	  pseudorandom function (PRF).

endmenu
menu "Userspace interface"

config CRYPTO_USER_API
	tristate
	help
	  Top-level selection for the AF_ALG userspace crypto interface. This
	  provides a socket-based API for applications to access the kernel's
	  cryptographic algorithms and hardware acceleration.

config CRYPTO_USER_API_HASH
	tristate "Hash algorithms"
	depends on NET
	select CRYPTO_HASH
	select CRYPTO_USER_API
	help
	  Enable userspace access to cryptographic hash algorithms (e.g.,
	  SHA-256, HMAC(SHA256)) via the AF_ALG socket interface.

	  See Documentation/crypto/userspace-if.rst and
	  https://www.chronox.de/libkcapi/html/index.html

config CRYPTO_USER_API_SKCIPHER
	tristate "Symmetric key cipher algorithms"
	depends on NET
	select CRYPTO_SKCIPHER
	select CRYPTO_USER_API
	help
	  Enable userspace access to symmetric key cipher algorithms (e.g.,
	  AES in CBC or CTR mode) via the AF_ALG socket interface.

	  See Documentation/crypto/userspace-if.rst and
	  https://www.chronox.de/libkcapi/html/index.html

config CRYPTO_USER_API_RNG
	tristate "RNG (random number generator) algorithms"
	depends on NET
	select CRYPTO_RNG
	select CRYPTO_USER_API
	help
	  Enable userspace access to Random Number Generator (RNG)
	  algorithms via the AF_ALG socket interface.

	  See Documentation/crypto/userspace-if.rst and
	  https://www.chronox.de/libkcapi/html/index.html

config CRYPTO_USER_API_RNG_CAVP
	bool "Enable CAVP testing of DRBG"
	depends on CRYPTO_USER_API_RNG && CRYPTO_DRBG
	help
	  Enable extra, non-standard APIs in the AF_ALG interface specifically
	  for conducting NIST Cryptographic Algorithm Validation Program (CAVP)
	  testing of the DRBG implementation. This allows for resetting DRBG
	  entropy and providing additional data for known-answer tests.

	  This should only be enabled for compliance testing. You should say
	  N unless you know what this is.

config CRYPTO_USER_API_AEAD
	tristate "AEAD cipher algorithms"
	depends on NET
	select CRYPTO_AEAD
	select CRYPTO_SKCIPHER
	select CRYPTO_USER_API
	help
	  Enable userspace access to Authenticated Encryption with Associated
	  Data (AEAD) cipher algorithms (e.g., GCM(AES)) via the AF_ALG
	  socket interface.

	  See Documentation/crypto/userspace-if.rst and
	  https://www.chronox.de/libkcapi/html/index.html

config CRYPTO_USER_API_ENABLE_OBSOLETE
	bool "Obsolete cryptographic algorithms"
	depends on CRYPTO_USER_API
	default y
	help
	  Allow the selection of obsolete cryptographic algorithms (e.g.,
	  DES, MD4) that may have been phased out from internal kernel use
	  but are still needed by legacy userspace applications via the
	  AF_ALG interface. Disabling this can provide a small security
	  hardening benefit by reducing the available attack surface.

endmenu

config CRYPTO_HASH_INFO
	bool

if !KMSAN # avoid false positives from assembly
if ARM
source "arch/arm/crypto/Kconfig"
endif
if ARM64
source "arch/arm64/crypto/Kconfig"
endif
if LOONGARCH
source "arch/loongarch/crypto/Kconfig"
endif
if MIPS
source "arch/mips/crypto/Kconfig"
endif
if PPC
source "arch/powerpc/crypto/Kconfig"
endif
if RISCV
source "arch/riscv/crypto/Kconfig"
endif
if S390
source "arch/s390/crypto/Kconfig"
endif
if SPARC
source "arch/sparc/crypto/Kconfig"
endif
if X86
source "arch/x86/crypto/Kconfig"
endif
endif

source "drivers/crypto/Kconfig"
source "crypto/asymmetric_keys/Kconfig"
source "certs/Kconfig"
source "crypto/krb5/Kconfig"

endif	# if CRYPTO
