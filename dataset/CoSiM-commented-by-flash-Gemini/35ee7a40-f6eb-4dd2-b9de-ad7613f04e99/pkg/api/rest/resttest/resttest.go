/*
Copyright 2014 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @file resttest.go
 * @brief Provides a testing framework for Kubernetes REST storage implementations.
 *
 * This file contains a comprehensive `Tester` utility designed to facilitate
 * the testing of `rest.Storage` implementations in Kubernetes. It offers a
 * structured approach to verify the correctness of Create, Update, Delete,
 * Get, and List operations, including various edge cases like validation,
 * namespace handling, graceful deletion, and error injection. This framework
 * helps ensure that REST storage backends adhere to Kubernetes API conventions
 * and behave as expected.
 */

package resttest

import (
	"fmt"
	"reflect"
	"strings"
	"testing"

	"github.com/coreos/go-etcd/etcd"
	"k8s.io/kubernetes/pkg/api"
	"k8s.io/kubernetes/pkg/api/errors"
	"k8s.io/kubernetes/pkg/api/rest"
	"k8s.io/kubernetes/pkg/conversion"
	"k8s.io/kubernetes/pkg/fields"
	"k8s.io/kubernetes/pkg/labels"
	"k8s.io/kubernetes/pkg/runtime"
	"k8s.io/kubernetes/pkg/tools"
	"k8s.io/kubernetes/pkg/util"
)

/**
 * @brief Tester provides a comprehensive framework for testing REST storage implementations.
 *
 * This struct encapsulates all necessary components and utilities for performing
 * various tests on a `rest.Storage` instance. It allows for setting up test
 * environments, injecting errors, and verifying expected behaviors of RESTful
 * API operations.
 *
 * @field T *testing.T: The standard Go testing.T object for reporting test failures.
 * @field storage rest.Storage: The REST storage implementation being tested.
 * @field storageError injectErrorFunc: A function to inject errors into the storage layer for testing error handling.
 * @field clusterScope bool: A flag indicating if the tested resource is cluster-scoped (true) or namespace-scoped (false).
 * @field generatesName bool: A flag indicating if the tested resource generates names automatically.
 */
type Tester struct {
	*testing.T
	storage       rest.Storage
	storageError  injectErrorFunc
	clusterScope  bool
	generatesName bool
}

/**
 * @brief injectErrorFunc is a function type for injecting errors into the storage layer.
 *
 * This function signature is used to define a callback that allows test cases
 * to simulate errors originating from the storage backend.
 *
 * @param err error: The error to be injected.
 */
type injectErrorFunc func(err error)

/**
 * @brief New creates a new `Tester` instance for testing REST storage.
 *
 * This function is the constructor for the `Tester` object. It initializes
 * the `Tester` with the provided testing context, storage implementation,
 * and an error injection function.
 *
 * @param t *testing.T: The Go testing.T instance.
 * @param storage rest.Storage: The REST storage implementation to be tested.
 * @param storageError injectErrorFunc: A function to inject errors into the storage.
 * @return *Tester: A pointer to a new `Tester` instance.
 */
func New(t *testing.T, storage rest.Storage, storageError injectErrorFunc) *Tester {
	return &Tester{
		T:            t,
		storage:      storage,
		storageError: storageError,
	}
}

/**
 * @brief withStorageError temporarily injects an error into the storage.
 *
 * This helper method is used to execute a function `fn` with a simulated
 * storage error. It sets the `storageError` function with `err` before
 * executing `fn`, and then resets it to `nil` afterwards. This allows
 * testing error handling paths in a controlled manner.
 *
 * @param err error: The error to inject.
 * @param fn func(): The function to execute while the error is injected.
 */
func (t *Tester) withStorageError(err error, fn func()) {
	t.storageError(err)
	defer t.storageError(nil)
	fn()
}

/**
 * @brief ClusterScope configures the Tester for cluster-scoped resources.
 *
 * This method sets the `clusterScope` flag to true, indicating that the
 * resource being tested is cluster-wide and does not belong to a specific
 * namespace.
 *
 * @return *Tester: The `Tester` instance with `clusterScope` set.
 */
func (t *Tester) ClusterScope() *Tester {
	t.clusterScope = true
	return t
}

/**
 * @brief GeneratesName configures the Tester for resources that generate names automatically.
 *
 * This method sets the `generatesName` flag to true, indicating that the
 * resource being tested will have its name automatically generated by the
 * API server if `metadata.generateName` is provided.
 *
 * @return *Tester: The `Tester` instance with `generatesName` set.
 */
func (t *Tester) GeneratesName() *Tester {
	t.generatesName = true
	return t
}

/**
 * @brief TestNamespace returns the namespace used for testing.
 *
 * This method determines the namespace that will be used for creating contexts
 * during tests. If `t.clusterScope` is true, it returns `api.NamespaceNone`,
 * otherwise it returns a fixed "test" namespace.
 *
 * @return string: The name of the test namespace.
 */
func (t *Tester) TestNamespace() string {
	if t.clusterScope {
		return api.NamespaceNone
	}
	return "test"
}

/**
 * @brief TestContext returns an API context suitable for testing.
 *
 * This method creates and returns an `api.Context` object that will be used
 * when making storage calls. The context's namespace is determined by the
 * `TestNamespace()` method, which respects the `clusterScope` setting.
 *
 * @return api.Context: A new API context for testing.
 */
func (t *Tester) TestContext() api.Context {
	if t.clusterScope {
		return api.NewContext()
	}
	return api.WithNamespace(api.NewContext(), t.TestNamespace())
}

/**
 * @brief getObjectMetaOrFail extracts `ObjectMeta` from a runtime object or fails the test.
 *
 * This helper method attempts to retrieve the `api.ObjectMeta` from a given
 * `runtime.Object`. If the object does not have `ObjectMeta`, it calls
 * `t.Fatalf` to stop the test with an error message.
 *
 * @param obj runtime.Object: The runtime object from which to extract `ObjectMeta`.
 * @return *api.ObjectMeta: A pointer to the extracted `ObjectMeta`.
 */
func (t *Tester) getObjectMetaOrFail(obj runtime.Object) *api.ObjectMeta {
	meta, err := api.ObjectMetaFor(obj)
	if err != nil {
		t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, obj)
	}
	return meta
}

/**
 * @brief copyOrDie creates a deep copy of a runtime object or panics.
 *
 * This utility function uses `api.Scheme.Copy` to create a deep copy of
 * the provided `runtime.Object`. If the copy operation fails, it panics.
 * This ensures that test modifications do not affect original objects.
 *
 * @param obj runtime.Object: The runtime object to copy.
 * @return runtime.Object: A deep copy of the input object.
 */
func copyOrDie(obj runtime.Object) runtime.Object {
	out, err := api.Scheme.Copy(obj)
	if err != nil {
		panic(err)
	}
	return out
}

/**
 * @brief AssignFunc is a function type for assigning objects to a storage backend.
 *
 * This type defines a function that takes a slice of `runtime.Object`s and
 * typically performs an operation that makes these objects available in the
 * storage being tested (e.g., by creating them).
 *
 * @param []runtime.Object: A slice of runtime objects to process.
 * @return []runtime.Object: A slice of processed runtime objects.
 */
type AssignFunc func([]runtime.Object) []runtime.Object
/**
 * @brief GetFunc is a function type for retrieving an object from a storage backend.
 *
 * This type defines a function that takes an `api.Context` and a `runtime.Object`
 * (typically containing the name/ID of the object to retrieve) and returns
 * the fetched `runtime.Object` or an error.
 *
 * @param api.Context: The API context for the operation.
 * @param runtime.Object: A prototype object used to specify the name/ID of the object to retrieve.
 * @return (runtime.Object, error): The retrieved runtime object and an error, if any.
 */
type GetFunc func(api.Context, runtime.Object) (runtime.Object, error)
/**
 * @brief SetFunc is a function type for setting an object in a storage backend.
 *
 * This type defines a function that takes an `api.Context` and a `runtime.Object`
 * and performs an operation that sets or updates this object in the storage
 * being tested.
 *
 * @param api.Context: The API context for the operation.
 * @param runtime.Object: The runtime object to set.
 * @return error: An error, if any occurred during the set operation.
 */
type SetFunc func(api.Context, runtime.Object) error
/**
 * @brief SetRVFunc is a function type for setting a resource version.
 *
 * This type defines a function that takes a `uint64` representing a resource
 * version. It's typically used to simulate setting a resource version on a
 * list object for testing list operations.
 *
 * @param uint64: The resource version to set.
 */
type SetRVFunc func(uint64)

/**
 * @brief TestCreate performs a series of tests for the Create operation.
 *
 * This method orchestrates various test cases related to the creation of
 * a runtime object, including:
 * - Verifying that metadata is correctly handled.
 * - Checking if names are generated correctly (if `generatesName` is true).
 * - Ensuring creation of already existing objects fails with an `AlreadyExists` error.
 * - Validating namespace handling (discarding or rejecting mismatches).
 * - Invoking validation logic for invalid objects.
 * - Verifying that user-provided metadata fields like UID and CreationTimestamp are reset.
 *
 * @param valid runtime.Object: A valid runtime object to use for successful creation tests.
 * @param setFn SetFunc: A function to set up existing objects for "already exists" tests.
 * @param getFn GetFunc: A function to retrieve objects for verification.
 * @param invalid ...runtime.Object: A variadic list of invalid runtime objects to test validation.
 */
func (t *Tester) TestCreate(valid runtime.Object, setFn SetFunc, getFn GetFunc, invalid ...runtime.Object) {
	t.testCreateHasMetadata(copyOrDie(valid))
	if !t.generatesName {
		t.testCreateGeneratesName(copyOrDie(valid))
		t.testCreateGeneratesNameReturnsServerTimeout(copyOrDie(valid))
	}
	t.testCreateEquals(copyOrDie(valid), getFn)
	t.testCreateAlreadyExisting(copyOrDie(valid), setFn)
	if t.clusterScope {
		t.testCreateDiscardsObjectNamespace(copyOrDie(valid))
		t.testCreateIgnoresContextNamespace(copyOrDie(valid))
		t.testCreateIgnoresMismatchedNamespace(copyOrDie(valid))
	} else {
		t.testCreateRejectsMismatchedNamespace(copyOrDie(valid))
	}
	t.testCreateInvokesValidation(invalid...)
}

/**
 * @brief TestUpdate performs a series of tests for the Update operation.
 *
 * This method orchestrates various test cases related to updating a runtime
 * object, including:
 * - Verifying that update fails when the object is not found.
 * - Ensuring updates fail on outdated resource versions to prevent conflicts.
 *
 * @param valid runtime.Object: A valid runtime object to use for successful update tests.
 * @param existing runtime.Object: An existing runtime object to use for testing updates to an already present resource.
 * @param older runtime.Object: An older version of a runtime object to test optimistic concurrency control.
 */
func (t *Tester) TestUpdate(valid runtime.Object, existing, older runtime.Object) {
	t.testUpdateFailsOnNotFound(copyOrDie(valid))
	t.testUpdateFailsOnVersion(copyOrDie(older))
}

/**
 * @brief TestDelete performs a series of tests for the Delete operation.
 *
 * This method orchestrates various test cases related to the deletion of
 * a runtime object, including:
 * - Verifying behavior when attempting to delete a non-existent object.
 * - Testing deletion of resources that do not support graceful deletion.
 * - Invoking validation logic for invalid deletion requests.
 *
 * @param createFn func() runtime.Object: A function that creates a new runtime object for testing.
 * @param wasGracefulFn func() bool: A function that returns true if the last deletion was graceful.
 * @param invalid ...runtime.Object: A variadic list of invalid runtime objects to test validation during deletion.
 */
func (t *Tester) TestDelete(createFn func() runtime.Object, wasGracefulFn func() bool, invalid ...runtime.Object) {
	t.TestDeleteNonExist(createFn)
	t.TestDeleteNoGraceful(createFn, wasGracefulFn)
	t.TestDeleteInvokesValidation(invalid...)
	// TODO: Test delete namespace mismatch rejection
	// once #5684 is fixed.
}

/**
 * @brief TestDeleteGraceful performs a series of tests for graceful Delete operations.
 *
 * This method orchestrates various test cases related to the graceful deletion
 * of a runtime object, including:
 * - Verifying that default graceful periods are applied correctly.
 * - Testing custom graceful periods.
 * - Ensuring that a nil DeleteOptions object defaults to zero grace period.
 * - Extending the graceful deletion period.
 * - Immediate deletion.
 *
 * @param createFn func() runtime.Object: A function that creates a new runtime object for testing.
 * @param expectedGrace int64: The expected graceful deletion period in seconds.
 * @param wasGracefulFn func() bool: A function that returns true if the last deletion was graceful.
 */
func (t *Tester) TestDeleteGraceful(createFn func() runtime.Object, expectedGrace int64, wasGracefulFn func() bool) {
	t.TestDeleteGracefulHasDefault(createFn(), expectedGrace, wasGracefulFn)
	t.TestDeleteGracefulWithValue(createFn(), expectedGrace, wasGracefulFn)
	t.TestDeleteGracefulUsesZeroOnNil(createFn(), 0)
	t.TestDeleteGracefulExtend(createFn(), expectedGrace, wasGracefulFn)
	t.TestDeleteGracefulImmediate(createFn(), expectedGrace, wasGracefulFn)
}

/**
 * @brief TestGet performs a series of tests for the Get operation.
 *
 * This method orchestrates various test cases related to retrieving a runtime
 * object, including:
 * - Verifying successful retrieval of an existing object.
 * - Ensuring that retrieval of a non-existent object results in a `NotFound` error.
 * - Testing behavior with mismatched namespaces (for both cluster-scoped and namespaced resources).
 * - Ensuring objects with the same name but different namespaces do not clash.
 *
 * @param obj runtime.Object: A prototype runtime object used for setup and verification.
 */
func (t *Tester) TestGet(obj runtime.Object) {
	t.testGetFound(obj)
	t.testGetNotFound(obj)
	t.testGetMimatchedNamespace(obj)
	if !t.clusterScope {
		t.testGetDifferentNamespace(obj)
	}
}

/**
 * @brief TestList performs a series of tests for the List operation.
 *
 * This method orchestrates various test cases related to listing runtime
 * objects, including:
 * - Verifying error handling during listing.
 * - Ensuring correct retrieval of existing objects.
 * - Testing behavior when no objects are found.
 * - Validating filtering by labels.
 *
 * @param obj runtime.Object: A prototype runtime object used for setup and verification.
 * @param assignFn AssignFunc: A function to assign (create) objects in the storage for testing.
 * @param setRVFn SetRVFunc: A function to set the resource version for list results.
 */
func (t *Tester) TestList(obj runtime.Object, assignFn AssignFunc, setRVFn SetRVFunc) {
	t.testListError()
	t.testListFound(obj, assignFn)
	t.testListNotFound(assignFn, setRVFn)
	t.testListMatchLabels(obj, assignFn)
}

// =============================================================================
// Creation tests.

/**
 * @brief testCreateAlreadyExisting verifies that creating an existing object returns an `AlreadyExists` error.
 *
 * This test case attempts to create an object with a name that already exists
 * in the storage (pre-populated using `setFn`). It asserts that the `Create`
 * operation returns an error indicating that the resource already exists.
 *
 * @param obj runtime.Object: The object to attempt to create (with a name that will conflict).
 * @param setFn SetFunc: A function to pre-create the object in storage.
 */
func (t *Tester) testCreateAlreadyExisting(obj runtime.Object, setFn SetFunc) {
	ctx := t.TestContext()

	foo := copyOrDie(obj)
	fooMeta := t.getObjectMetaOrFail(foo)
	fooMeta.Name = "foo1"
	fooMeta.Namespace = api.NamespaceValue(ctx)
	fooMeta.GenerateName = ""
	if err := setFn(ctx, foo); err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	_, err := t.storage.(rest.Creater).Create(ctx, foo)
	if !errors.IsAlreadyExists(err) {
		t.Errorf("expected already exists err, got %v", err)
	}
}

/**
 * @brief testCreateEquals verifies that a created object matches the retrieved object.
 *
 * This test case creates a new object and then immediately retrieves it from
 * storage using `getFn`. It asserts that the retrieved object is semantically
 * deep equal to the object that was created, after adjusting for fields
 * like `ResourceVersion` that are set by the storage layer.
 *
 * @param obj runtime.Object: The object to create and then verify.
 * @param getFn GetFunc: A function to retrieve the created object from storage.
 */
func (t *Tester) testCreateEquals(obj runtime.Object, getFn GetFunc) {
	ctx := t.TestContext()

	foo := copyOrDie(obj)
	fooMeta := t.getObjectMetaOrFail(foo)
	fooMeta.Name = "foo2"
	fooMeta.Namespace = api.NamespaceValue(ctx)
	fooMeta.GenerateName = ""

	created, err := t.storage.(rest.Creater).Create(ctx, foo)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	got, err := getFn(ctx, foo)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Set resource version which might be unset in created object.
	createdMeta := t.getObjectMetaOrFail(created)
	gotMeta := t.getObjectMetaOrFail(got)
	createdMeta.ResourceVersion = gotMeta.ResourceVersion

	if e, a := created, got; !api.Semantic.DeepEqual(e, a) {
		t.Errorf("unexpected obj: %#v, expected %#v", e, a)
	}
}

/**
 * @brief testCreateDiscardsObjectNamespace verifies that the namespace in a cluster-scoped object is discarded.
 *
 * This test case is relevant for cluster-scoped resources. It asserts that
 * if an object submitted for creation has a non-empty namespace defined in its
 * `ObjectMeta`, this namespace is discarded by the storage layer, resulting
 * in an empty namespace on the created object.
 *
 * @param valid runtime.Object: A valid runtime object with a namespace to be discarded.
 */
func (t *Tester) testCreateDiscardsObjectNamespace(valid runtime.Object) {
	objectMeta := t.getObjectMetaOrFail(valid)

	// Ignore non-empty namespace in object meta
	objectMeta.Namespace = "not-default"

	// Ideally, we'd get an error back here, but at least verify the namespace wasn't persisted
	created, err := t.storage.(rest.Creater).Create(t.TestContext(), copyOrDie(valid))
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	createdObjectMeta := t.getObjectMetaOrFail(created)
	if createdObjectMeta.Namespace != api.NamespaceNone {
		t.Errorf("Expected empty namespace on created object, got '%v'", createdObjectMeta.Namespace)
	}
}

/**
 * @brief testCreateGeneratesName verifies that a name is generated when `GenerateName` is provided.
 *
 * This test case sets the `metadata.generateName` field on an object and
 * asserts that the storage layer generates a unique name for the object
 * upon creation, using the provided prefix.
 *
 * @param valid runtime.Object: A valid runtime object with `GenerateName` set.
 */
func (t *Tester) testCreateGeneratesName(valid runtime.Object) {
	objectMeta := t.getObjectMetaOrFail(valid)
	objectMeta.Name = ""
	objectMeta.GenerateName = "test-"

	_, err := t.storage.(rest.Creater).Create(t.TestContext(), valid)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if objectMeta.Name == "test-" || !strings.HasPrefix(objectMeta.Name, "test-") {
		t.Errorf("unexpected name: %#v", valid)
	}
}

/**
 * @brief testCreateGeneratesNameReturnsServerTimeout verifies error handling when name generation conflicts.
 *
 * This test case simulates a scenario where the storage backend returns an
 * `AlreadyExists` error during an attempt to create an object with `GenerateName`.
 * It asserts that this conflict is properly translated into a `ServerTimeout`
 * error by the REST storage layer.
 *
 * @param valid runtime.Object: A valid runtime object with `GenerateName` set.
 */
func (t *Tester) testCreateGeneratesNameReturnsServerTimeout(valid runtime.Object) {
	objectMeta := t.getObjectMetaOrFail(valid)
	objectMeta.Name = ""
	objectMeta.GenerateName = "test-"
	t.withStorageError(errors.NewAlreadyExists("kind", "thing"), func() {
		_, err := t.storage.(rest.Creater).Create(t.TestContext(), valid)
		if err == nil || !errors.IsServerTimeout(err) {
			t.Fatalf("Unexpected error: %v", err)
		}
	})
}

/**
 * @brief testCreateHasMetadata verifies that `ObjectMeta` fields are populated on creation.
 *
 * This test case creates a new object and asserts that essential `ObjectMeta`
 * fields, such as `UID`, `CreationTimestamp`, and `ResourceVersion`, are
 * automatically populated by the storage layer upon successful creation.
 *
 * @param valid runtime.Object: A valid runtime object to create.
 */
func (t *Tester) testCreateHasMetadata(valid runtime.Object) {
	objectMeta := t.getObjectMetaOrFail(valid)
	objectMeta.Name = ""
	objectMeta.GenerateName = "test-"
	objectMeta.Namespace = t.TestNamespace()

	obj, err := t.storage.(rest.Creater).Create(t.TestContext(), valid)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if obj == nil {
		t.Fatalf("Unexpected object from result: %#v", obj)
	}
	if !api.HasObjectMetaSystemFieldValues(objectMeta) {
		t.Errorf("storage did not populate object meta field values")
	}
}

/**
 * @brief testCreateIgnoresContextNamespace verifies that the context namespace is ignored for cluster-scoped objects.
 *
 * This test case is relevant for cluster-scoped resources. It asserts that
 * if an object is created with a non-empty namespace in the `api.Context`,
 * this context namespace is ignored by the storage layer, and the created
 * object still has an empty namespace.
 *
 * @param valid runtime.Object: A valid runtime object to create.
 */
func (t *Tester) testCreateIgnoresContextNamespace(valid runtime.Object) {
	// Ignore non-empty namespace in context
	ctx := api.WithNamespace(api.NewContext(), "not-default2")

	// Ideally, we'd get an error back here, but at least verify the namespace wasn't persisted
	created, err := t.storage.(rest.Creater).Create(ctx, copyOrDie(valid))
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	createdObjectMeta := t.getObjectMetaOrFail(created)
	if createdObjectMeta.Namespace != api.NamespaceNone {
		t.Errorf("Expected empty namespace on created object, got '%v'", createdObjectMeta.Namespace)
	}
}

/**
 * @brief testCreateIgnoresMismatchedNamespace verifies that mismatched namespaces are ignored for cluster-scoped objects.
 *
 * This test case is relevant for cluster-scoped resources. It asserts that
 * if an object with a non-empty namespace in its `ObjectMeta` is created
 * with a different non-empty namespace in the `api.Context`, both namespaces
 * are ignored, and the created object still has an empty namespace.
 *
 * @param valid runtime.Object: A valid runtime object with a namespace to be ignored.
 */
func (t *Tester) testCreateIgnoresMismatchedNamespace(valid runtime.Object) {
	objectMeta := t.getObjectMetaOrFail(valid)

	// Ignore non-empty namespace in object meta
	objectMeta.Namespace = "not-default"
	ctx := api.WithNamespace(api.NewContext(), "not-default2")

	// Ideally, we'd get an error back here, but at least verify the namespace wasn't persisted
	created, err := t.storage.(rest.Creater).Create(ctx, copyOrDie(valid))
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	createdObjectMeta := t.getObjectMetaOrFail(created)
	if createdObjectMeta.Namespace != api.NamespaceNone {
		t.Errorf("Expected empty namespace on created object, got '%v'", createdObjectMeta.Namespace)
	}
}

/**
 * @brief testCreateInvokesValidation verifies that invalid objects are rejected during creation.
 *
 * This test case attempts to create a series of `invalid` runtime objects.
 * It asserts that each creation attempt fails with an `IsInvalid` error,
 * demonstrating that the storage layer's validation logic is correctly invoked.
 *
 * @param invalid ...runtime.Object: A variadic list of invalid runtime objects to test.
 */
func (t *Tester) testCreateInvokesValidation(invalid ...runtime.Object) {
	for i, obj := range invalid {
		ctx := t.TestContext()
		_, err := t.storage.(rest.Creater).Create(ctx, obj)
		if !errors.IsInvalid(err) {
			t.Errorf("%d: Expected to get an invalid resource error, got %v", i, err)
		}
	}
}

/**
 * @brief testCreateRejectsMismatchedNamespace verifies that creating namespaced objects with mismatched namespaces is rejected.
 *
 * This test case is relevant for namespaced resources. It asserts that
 * if an object is created with a namespace in its `ObjectMeta` that does
 * not match the namespace provided in the `api.Context`, the creation
 * operation is rejected with an appropriate error.
 *
 * @param valid runtime.Object: A valid runtime object with a mismatched namespace.
 */
func (t *Tester) testCreateRejectsMismatchedNamespace(valid runtime.Object) {
	objectMeta := t.getObjectMetaOrFail(valid)
	objectMeta.Namespace = "not-default"

	_, err := t.storage.(rest.Creater).Create(t.TestContext(), valid)
	if err == nil {
		t.Errorf("Expected an error, but we didn't get one")
	} else if !strings.Contains(err.Error(), "does not match the namespace sent on the request") {
		t.Errorf("Expected 'does not match the namespace sent on the request' error, got '%v'", err.Error())
	}
}

/**
 * @brief testCreateResetsUserData verifies that certain user-provided metadata fields are reset on creation.
 *
 * This test case ensures that fields like `UID` and `CreationTimestamp`
 * provided by the user in `ObjectMeta` are automatically reset by the
 * storage layer upon object creation, as these fields are typically
 * server-managed.
 *
 * @param valid runtime.Object: A valid runtime object with pre-set `UID` and `CreationTimestamp`.
 */
func (t *Tester) testCreateResetsUserData(valid runtime.Object) {
	objectMeta := t.getObjectMetaOrFail(valid)
	now := util.Now()
	objectMeta.UID = "bad-uid"
	objectMeta.CreationTimestamp = now

	obj, err := t.storage.(rest.Creater).Create(t.TestContext(), valid)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if obj == nil {
		t.Fatalf("Unexpected object from result: %#v", obj)
	}
	if objectMeta.UID == "bad-uid" || objectMeta.CreationTimestamp == now {
		t.Errorf("ObjectMeta did not reset basic fields: %#v", objectMeta)
	}
}

// =============================================================================
// Update tests.

/**
 * @brief testUpdateFailsOnNotFound verifies that updating a non-existent object returns a `NotFound` error.
 *
 * This test case attempts to update an object that does not exist in the
 * storage. It asserts that the `Update` operation correctly returns a
 * `NotFound` error.
 *
 * @param valid runtime.Object: A valid runtime object (that is not in storage) to attempt to update.
 */
func (t *Tester) testUpdateFailsOnNotFound(valid runtime.Object) {
	_, _, err := t.storage.(rest.Updater).Update(t.TestContext(), valid)
	if err == nil {
		t.Errorf("Expected an error, but we didn't get one")
	} else if !errors.IsNotFound(err) {
		t.Errorf("Expected NotFound error, got '%v'", err)
	}
}

/**
 * @brief testUpdateFailsOnVersion verifies that updating with an outdated resource version returns a `Conflict` error.
 *
 * This test case attempts to update an object using an `older` resource
 * version. It asserts that the `Update` operation correctly returns a
 * `Conflict` error, enforcing optimistic concurrency control.
 *
 * @param older runtime.Object: An object with an outdated resource version to attempt to update.
 */
func (t *Tester) testUpdateFailsOnVersion(older runtime.Object) {
	_, _, err := t.storage.(rest.Updater).Update(t.TestContext(), older)
	if err == nil {
		t.Errorf("Expected an error, but we didn't get one")
	} else if !errors.IsConflict(err) {
		t.Errorf("Expected Conflict error, got '%v'", err)
	}
}

// =============================================================================
// Deletion tests.

/**
 * @brief TestDeleteInvokesValidation verifies that invalid deletion requests are rejected.
 *
 * This test case attempts to delete a series of `invalid` runtime objects.
 * It asserts that each deletion attempt fails with an `IsInvalid` error,
 * demonstrating that the storage layer's validation logic is correctly invoked
 * for delete operations.
 *
 * @param invalid ...runtime.Object: A variadic list of invalid runtime objects to test deletion with.
 */
func (t *Tester) TestDeleteInvokesValidation(invalid ...runtime.Object) {
	for i, obj := range invalid {
		objectMeta := t.getObjectMetaOrFail(obj)
		ctx := t.TestContext()
		_, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, nil)
		if !errors.IsInvalid(err) {
			t.Errorf("%d: Expected to get an invalid resource error, got %v", i, err)
		}
	}
}

/**
 * @brief TestDeleteNonExist verifies that deleting a non-existent object returns a `NotFound` error.
 *
 * This test case simulates an attempt to delete an object that is not present
 * in the storage. It uses `t.withStorageError` to inject a simulated Etcd
 * `NotFound` error and asserts that the `Delete` operation correctly
 * translates this into a Kubernetes `NotFound` error.
 *
 * @param createFn func() runtime.Object: A function that creates a new runtime object (which is then not actually stored).
 */
func (t *Tester) TestDeleteNonExist(createFn func() runtime.Object) {
	existing := createFn()
	objectMeta := t.getObjectMetaOrFail(existing)
	context := t.TestContext()

	t.withStorageError(&etcd.EtcdError{ErrorCode: tools.EtcdErrorCodeNotFound}, func() {
		_, err := t.storage.(rest.GracefulDeleter).Delete(context, objectMeta.Name, nil)
		if err == nil || !errors.IsNotFound(err) {
			t.Fatalf("Unexpected error: %v", err)
		}
	})
}

// =============================================================================
// Graceful Deletion tests.

/**
 * @brief TestDeleteNoGraceful verifies deletion behavior for resources not supporting graceful deletion.
 *
 * This test case simulates deleting a resource with a graceful period specified,
 * but where the resource itself does not support graceful deletion. It asserts
 * that the resource is immediately deleted and that `wasGracefulFn` correctly
 * reports that no graceful deletion occurred.
 *
 * @param createFn func() runtime.Object: A function that creates a new runtime object for testing.
 * @param wasGracefulFn func() bool: A function that returns true if the last deletion was graceful.
 */
func (t *Tester) TestDeleteNoGraceful(createFn func() runtime.Object, wasGracefulFn func() bool) {
	existing := createFn()
	objectMeta := t.getObjectMetaOrFail(existing)
	ctx := api.WithNamespace(t.TestContext(), objectMeta.Namespace)
	_, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, api.NewDeleteOptions(10))
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if _, err := t.storage.(rest.Getter).Get(ctx, objectMeta.Name); !errors.IsNotFound(err) {
		t.Errorf("unexpected error, object should not exist: %v", err)
	}
	if wasGracefulFn() {
		t.Errorf("resource should not support graceful delete")
	}
}

/**
 * @brief TestDeleteGracefulHasDefault verifies that default graceful deletion periods are applied.
 *
 * This test case simulates a graceful deletion request without specifying a
 * `DeletionGracePeriodSeconds` in the `DeleteOptions`. It asserts that the
 * storage layer applies a default graceful period, and that the object's
 * `DeletionTimestamp` and `DeletionGracePeriodSeconds` are set correctly.
 *
 * @param existing runtime.Object: An existing runtime object to be gracefully deleted.
 * @param expectedGrace int64: The expected default graceful deletion period in seconds.
 * @param wasGracefulFn func() bool: A function that returns true if the last deletion was graceful.
 */
func (t *Tester) TestDeleteGracefulHasDefault(existing runtime.Object, expectedGrace int64, wasGracefulFn func() bool) {
	objectMeta := t.getObjectMetaOrFail(existing)
	ctx := api.WithNamespace(t.TestContext(), objectMeta.Namespace)
	_, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, &api.DeleteOptions{})
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if !wasGracefulFn() {
		t.Errorf("did not gracefully delete resource")
		return
	}
	object, err := t.storage.(rest.Getter).Get(ctx, objectMeta.Name)
	if err != nil {
		t.Errorf("unexpected error, object should exist: %v", err)
		return
	}
	objectMeta, err = api.ObjectMetaFor(object)
	if err != nil {
		t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, object)
	}
	if objectMeta.DeletionTimestamp == nil {
		t.Errorf("did not set deletion timestamp")
	}
	if objectMeta.DeletionGracePeriodSeconds == nil {
		t.Fatalf("did not set deletion grace period seconds")
	}
	if *objectMeta.DeletionGracePeriodSeconds != expectedGrace {
		t.Errorf("actual grace period does not match expected: %d", *objectMeta.DeletionGracePeriodSeconds)
	}
}

/**
 * @brief TestDeleteGracefulWithValue verifies that custom graceful deletion periods are applied.
 *
 * This test case simulates a graceful deletion request with a specific
 * `DeletionGracePeriodSeconds` value. It asserts that the storage layer
 * correctly applies this custom graceful period, and that the object's
 * `DeletionTimestamp` and `DeletionGracePeriodSeconds` are set accordingly.
 *
 * @param existing runtime.Object: An existing runtime object to be gracefully deleted.
 * @param expectedGrace int64: The expected custom graceful deletion period in seconds.
 * @param wasGracefulFn func() bool: A function that returns true if the last deletion was graceful.
 */
func (t *Tester) TestDeleteGracefulWithValue(existing runtime.Object, expectedGrace int64, wasGracefulFn func() bool) {
	objectMeta, err := api.ObjectMetaFor(existing)
	if err != nil {
		t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, existing)
	}

	ctx := api.WithNamespace(t.TestContext(), objectMeta.Namespace)
	_, err = t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, api.NewDeleteOptions(expectedGrace+2))
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if !wasGracefulFn() {
		t.Errorf("did not gracefully delete resource")
	}
	object, err := t.storage.(rest.Getter).Get(ctx, objectMeta.Name)
	if err != nil {
		t.Errorf("unexpected error, object should exist: %v", err)
	}
	objectMeta, err = api.ObjectMetaFor(object)
	if err != nil {
		t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, object)
	}
	if objectMeta.DeletionTimestamp == nil {
		t.Errorf("did not set deletion timestamp")
	}
	if objectMeta.DeletionGracePeriodSeconds == nil {
		t.Fatalf("did not set deletion grace period seconds")
	}
	if *objectMeta.DeletionGracePeriodSeconds != expectedGrace+2 {
		t.Errorf("actual grace period does not match expected: %d", *objectMeta.DeletionGracePeriodSeconds)
	}
}

/**
 * @brief TestDeleteGracefulExtend verifies that a graceful deletion period cannot be extended.
 *
 * This test case simulates an initial graceful deletion request, followed by a
 * second request with a longer graceful period. It asserts that the second
 * request's duration is ignored, and the original graceful period remains in effect.
 *
 * @param existing runtime.Object: An existing runtime object to be gracefully deleted.
 * @param expectedGrace int64: The initial expected graceful deletion period in seconds.
 * @param wasGracefulFn func() bool: A function that returns true if the last deletion was graceful.
 */
func (t *Tester) TestDeleteGracefulExtend(existing runtime.Object, expectedGrace int64, wasGracefulFn func() bool) {
	objectMeta, err := api.ObjectMetaFor(existing)
	if err != nil {
		t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, existing)
	}

	ctx := api.WithNamespace(t.TestContext(), objectMeta.Namespace)
	_, err = t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, api.NewDeleteOptions(expectedGrace))
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if !wasGracefulFn() {
		t.Errorf("did not gracefully delete resource")
	}
	// second delete duration is ignored
	_, err = t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, api.NewDeleteOptions(expectedGrace+2))
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	object, err := t.storage.(rest.Getter).Get(ctx, objectMeta.Name)
	if err != nil {
		t.Errorf("unexpected error, object should exist: %v", err)
	}
	objectMeta, err = api.ObjectMetaFor(object)
	if err != nil {
		t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, object)
	}
	if objectMeta.DeletionTimestamp == nil {
		t.Errorf("did not set deletion timestamp")
	}
	if objectMeta.DeletionGracePeriodSeconds == nil {
		t.Fatalf("did not set deletion grace period seconds")
	}
	if *objectMeta.DeletionGracePeriodSeconds != expectedGrace {
		t.Errorf("actual grace period does not match expected: %d", *objectMeta.DeletionGracePeriodSeconds)
	}
}

/**
 * @brief TestDeleteGracefulImmediate verifies immediate deletion during a graceful period.
 *
 * This test case simulates a scenario where an object is already undergoing
 * graceful deletion, and a subsequent deletion request with a zero graceful
 * period (`DeleteOptions(0)`) is issued. It asserts that the object is
 * immediately deleted, overriding the pending graceful period.
 *
 * @param existing runtime.Object: An existing runtime object undergoing graceful deletion.
 * @param expectedGrace int64: The initial expected graceful deletion period in seconds.
 * @param wasGracefulFn func() bool: A function that returns true if the last deletion was graceful.
 */
func (t *Tester) TestDeleteGracefulImmediate(existing runtime.Object, expectedGrace int64, wasGracefulFn func() bool) {
	objectMeta, err := api.ObjectMetaFor(existing)
	if err != nil {
		t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, existing)
	}

	ctx := api.WithNamespace(t.TestContext(), objectMeta.Namespace)
	_, err = t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, api.NewDeleteOptions(expectedGrace))
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if !wasGracefulFn() {
		t.Errorf("did not gracefully delete resource")
	}
	// second delete is immediate, resource is deleted
	out, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, api.NewDeleteOptions(0))
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	_, err = t.storage.(rest.Getter).Get(ctx, objectMeta.Name)
	if !errors.IsNotFound(err) {
		t.Errorf("unexpected error, object should be deleted immediately: %v", err)
	}
	objectMeta, err = api.ObjectMetaFor(out)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
		return
	}
	if objectMeta.DeletionTimestamp == nil || objectMeta.DeletionGracePeriodSeconds == nil || *objectMeta.DeletionGracePeriodSeconds != 0 {
		t.Errorf("unexpected deleted meta: %#v", objectMeta)
	}
}

/**
 * @brief TestDeleteGracefulUsesZeroOnNil verifies that a nil DeleteOptions object results in immediate deletion.
 *
 * This test case simulates a deletion request where `DeleteOptions` is `nil`.
 * It asserts that the storage layer interprets this as a request for immediate
 * deletion (grace period of zero), and that the object is promptly removed.
 *
 * @param existing runtime.Object: An existing runtime object to be deleted.
 * @param expectedGrace int64: The expected graceful deletion period in seconds (should be 0 for immediate deletion).
 */
func (t *Tester) TestDeleteGracefulUsesZeroOnNil(existing runtime.Object, expectedGrace int64) {
	objectMeta := t.getObjectMetaOrFail(existing)
	ctx := api.WithNamespace(t.TestContext(), objectMeta.Namespace)
	_, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.Name, nil)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if _, err := t.storage.(rest.Getter).Get(ctx, objectMeta.Name); !errors.IsNotFound(err) {
		t.Errorf("unexpected error, object should not exist: %v", err)
	}
}

// =============================================================================
// Get tests.

// testGetDifferentNamespace ensures same-name objects in different namespaces do not clash
/**
 * @brief testGetDifferentNamespace verifies that objects with the same name in different namespaces do not clash.
 *
 * This test case is relevant for namespaced resources. It creates two objects
 * with the same name but in different namespaces and asserts that they can
 * be retrieved independently without interference, ensuring proper namespace
 * isolation. This test does not apply to cluster-scoped resources.
 *
 * @param obj runtime.Object: A prototype runtime object to be used for creating instances in different namespaces.
 */
func (t *Tester) testGetDifferentNamespace(obj runtime.Object) {
	if t.clusterScope {
		t.Fatalf("the test does not work in in cluster-scope")
	}

	objMeta := t.getObjectMetaOrFail(obj)
	objMeta.Name = "foo5"

	ctx1 := api.WithNamespace(api.NewContext(), "bar3")
	objMeta.Namespace = api.NamespaceValue(ctx1)
	_, err := t.storage.(rest.Creater).Create(ctx1, obj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	ctx2 := api.WithNamespace(api.NewContext(), "bar4")
	objMeta.Namespace = api.NamespaceValue(ctx2)
	_, err = t.storage.(rest.Creater).Create(ctx2, obj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	got1, err := t.storage.(rest.Getter).Get(ctx1, objMeta.Name)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	got1Meta := t.getObjectMetaOrFail(got1)
	if got1Meta.Name != objMeta.Name {
		t.Errorf("unexpected name of object: %#v, expected: %s", got1, objMeta.Name)
	}
	if got1Meta.Namespace != api.NamespaceValue(ctx1) {
		t.Errorf("unexpected namespace of object: %#v, expected: %s", got1, api.NamespaceValue(ctx1))
	}

	got2, err := t.storage.(rest.Getter).Get(ctx2, objMeta.Name)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	got2Meta := t.getObjectMetaOrFail(got2)
	if got2Meta.Name != objMeta.Name {
		t.Errorf("unexpected name of object: %#v, expected: %s", got2, objMeta.Name)
	}
	if got2Meta.Namespace != api.NamespaceValue(ctx2) {
		t.Errorf("unexpected namespace of object: %#v, expected: %s", got2, api.NamespaceValue(ctx2))
	}
}

/**
 * @brief testGetFound verifies that an existing object can be successfully retrieved.
 *
 * This test case creates a new object in storage and then attempts to retrieve
 * it by name. It asserts that the retrieval is successful and that the
 * retrieved object is semantically deep equal to the original object (after
 * adjusting for server-assigned metadata).
 *
 * @param obj runtime.Object: The object to create and then retrieve.
 */
func (t *Tester) testGetFound(obj runtime.Object) {
	ctx := t.TestContext()
	objMeta := t.getObjectMetaOrFail(obj)
	objMeta.Name = "foo1"
	objMeta.Namespace = api.NamespaceValue(ctx)

	existing, err := t.storage.(rest.Creater).Create(ctx, obj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	existingMeta := t.getObjectMetaOrFail(existing)

	got, err := t.storage.(rest.Getter).Get(ctx, "foo1")
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	gotMeta := t.getObjectMetaOrFail(got)
	gotMeta.ResourceVersion = existingMeta.ResourceVersion
	if e, a := existing, got; !api.Semantic.DeepEqual(e, a) {
		t.Errorf("unexpected obj: %#v, expected %#v", e, a)
	}
}

/**
 * @brief testGetMimatchedNamespace verifies retrieval behavior with mismatched namespaces.
 *
 * This test case creates an object in one namespace and then attempts to
 * retrieve it from a different namespace. It asserts that for namespaced
 * resources, this results in a `NotFound` error, while for cluster-scoped
 * resources, the operation might succeed (as namespaces are ignored).
 *
 * @param obj runtime.Object: A prototype runtime object to be used for testing.
 */
func (t *Tester) testGetMimatchedNamespace(obj runtime.Object) {
	ctx1 := api.WithNamespace(api.NewContext(), "bar1")
	ctx2 := api.WithNamespace(api.NewContext(), "bar2")
	objMeta := t.getObjectMetaOrFail(obj)
	objMeta.Name = "foo4"
	objMeta.Namespace = api.NamespaceValue(ctx1)
	_, err := t.storage.(rest.Creater).Create(ctx1, obj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	_, err = t.storage.(rest.Getter).Get(ctx2, "foo4")
	if t.clusterScope {
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}
	} else {
		if !errors.IsNotFound(err) {
			t.Errorf("unexpected error returned: %#v", err)
		}
	}
}

/**
 * @brief testGetNotFound verifies that retrieving a non-existent object returns a `NotFound` error.
 *
 * This test case creates an object and then attempts to retrieve a different
 * (non-existent) object. It asserts that the `Get` operation correctly returns
 * a `NotFound` error for the non-existent resource.
 *
 * @param obj runtime.Object: A prototype runtime object used for setup.
 */
func (t *Tester) testGetNotFound(obj runtime.Object) {
	ctx := t.TestContext()
	objMeta := t.getObjectMetaOrFail(obj)
	objMeta.Name = "foo2"
	objMeta.Namespace = api.NamespaceValue(ctx)
	_, err := t.storage.(rest.Creater).Create(ctx, obj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	_, err = t.storage.(rest.Getter).Get(ctx, "foo3")
	if !errors.IsNotFound(err) {
		t.Errorf("unexpected error returned: %#v", err)
	}
}

// =============================================================================
// List tests.

/**
 * @brief listToItems extracts a slice of `runtime.Object`s from a list object.
 *
 * This utility function takes a `runtime.Object` that is expected to be a list
 * type (e.g., `*api.PodList`) and extracts the `Items` field into a generic
 * slice of `runtime.Object`s. It performs reflection to access the `Items` field.
 *
 * @param listObj runtime.Object: The list object (e.g., `*api.PodList`) from which to extract items.
 * @return ([]runtime.Object, error): A slice of runtime objects and an error, if any.
 */
func listToItems(listObj runtime.Object) ([]runtime.Object, error) {
	v, err := conversion.EnforcePtr(listObj)
	if err != nil {
		return nil, fmt.Errorf("unexpected error: %v", err)
	}
	items := v.FieldByName("Items")
	if !items.IsValid() {
		return nil, fmt.Errorf("unexpected Items field in %v", listObj)
	}
	if items.Type().Kind() != reflect.Slice {
		return nil, fmt.Errorf("unexpected Items field type: %v", items.Type().Kind())
	}
	result := make([]runtime.Object, items.Len())
	for i := 0; i < items.Len(); i++ {
		result[i] = items.Index(i).Addr().Interface().(runtime.Object)
	}
	return result, nil
}

/**
 * @brief testListError verifies that errors during listing are correctly propagated.
 *
 * This test case injects a simulated storage error into the `List` operation
 * and asserts that the error returned by the `List` method matches the
 * injected error.
 *
 * @param None
 */
func (t *Tester) testListError() {
	ctx := t.TestContext()

	storageError := fmt.Errorf("test error")
	t.withStorageError(storageError, func() {
		_, err := t.storage.(rest.Lister).List(ctx, labels.Everything(), fields.Everything())
		if err != storageError {
			t.Errorf("unexpected error: %v", err)
		}
	})
}

/**
 * @brief testListFound verifies that existing objects are correctly listed.
 *
 * This test case creates a set of objects using `assignFn` and then attempts
 * to list all objects using `List`. It asserts that the returned list
 * contains the same number of items as created and that the items themselves
 * are semantically deep equal to the created ones.
 *
 * @param obj runtime.Object: A prototype runtime object used for creating test instances.
 * @param assignFn AssignFunc: A function to pre-populate the storage with test objects.
 */
func (t *Tester) testListFound(obj runtime.Object, assignFn AssignFunc) {
	ctx := t.TestContext()

	foo1 := copyOrDie(obj)
	foo1Meta := t.getObjectMetaOrFail(foo1)
	foo1Meta.Name = "foo1"
	foo1Meta.Namespace = api.NamespaceValue(ctx)
	foo2 := copyOrDie(obj)
	foo2Meta := t.getObjectMetaOrFail(foo2)
	foo2Meta.Name = "foo2"
	foo2Meta.Namespace = api.NamespaceValue(ctx)

	existing := assignFn([]runtime.Object{foo1, foo2})

	listObj, err := t.storage.(rest.Lister).List(ctx, labels.Everything(), fields.Everything())
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	items, err := listToItems(listObj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if len(items) != len(existing) {
		t.Errorf("unexpected number of items: %v", len(items))
	}
	if !api.Semantic.DeepEqual(existing, items) {
		t.Errorf("expected: %#v, got: %#v", existing, items)
	}
}

/**
 * @brief testListMatchLabels verifies that listing with label selectors correctly filters objects.
 *
 * This test case creates a set of objects, some with specific labels. It then
 * attempts to list objects using a `labels.Selector` that matches only a subset
 * of the created objects. It asserts that the returned list contains only the
 * objects that match the label selector.
 *
 * @param obj runtime.Object: A prototype runtime object used for creating test instances.
 * @param assignFn AssignFunc: A function to pre-populate the storage with test objects.
 */
func (t *Tester) testListMatchLabels(obj runtime.Object, assignFn AssignFunc) {
	ctx := t.TestContext()
	testLabels := map[string]string{"key": "value"}

	foo1 := copyOrDie(obj)
	foo1Meta := t.getObjectMetaOrFail(foo1)
	foo1Meta.Name = "foo1"
	foo1Meta.Namespace = api.NamespaceValue(ctx)
	foo2 := copyOrDie(obj)
	foo2Meta := t.getObjectMetaOrFail(foo2)
	foo2Meta.Name = "foo2"
	foo2Meta.Namespace = api.NamespaceValue(ctx)
	foo2Meta.Labels = testLabels

	existing := assignFn([]runtime.Object{foo1, foo2})
	filtered := []runtime.Object{existing[1]}

	selector := labels.SelectorFromSet(labels.Set(testLabels))
	listObj, err := t.storage.(rest.Lister).List(ctx, selector, fields.Everything())
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	items, err := listToItems(listObj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if len(items) != len(filtered) {
		t.Errorf("unexpected number of items: %v", len(items))
	}
	if !api.Semantic.DeepEqual(filtered, items) {
		t.Errorf("expected: %#v, got: %#v", filtered, items)
	}
}

/**
 * @brief testListNotFound verifies that listing when no objects match returns an empty list.
 *
 * This test case simulates listing objects when no objects match the criteria
 * (or when the storage is empty). It asserts that an empty list is returned
 * and that the resource version is correctly set by `setRVFn`.
 *
 * @param assignFn AssignFunc: A function to ensure no objects are assigned to storage.
 * @param setRVFn SetRVFunc: A function to set the resource version for the list result.
 */
func (t *Tester) testListNotFound(assignFn AssignFunc, setRVFn SetRVFunc) {
	ctx := t.TestContext()

	setRVFn(uint64(123))
	_ = assignFn([]runtime.Object{})

	listObj, err := t.storage.(rest.Lister).List(ctx, labels.Everything(), fields.Everything())
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	items, err := listToItems(listObj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if len(items) != 0 {
		t.Errorf("unexpected items: %v", items)
	}

	meta, err := api.ListMetaFor(listObj)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if meta.ResourceVersion != "123" {
		t.Errorf("unexpected resource version: %d", meta.ResourceVersion)
	}
}
